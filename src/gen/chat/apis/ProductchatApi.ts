/* tslint:disable */
/* eslint-disable */
/**
 * Stream API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v122.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  APIError,
  BanRequest,
  BlockUsersRequest,
  BlockUsersResponse,
  CastPollVoteRequest,
  ChannelGetOrCreateRequest,
  ChannelStateResponse,
  CheckExternalStorageResponse,
  CheckPushRequest,
  CheckPushResponse,
  CheckSNSRequest,
  CheckSNSResponse,
  CheckSQSRequest,
  CheckSQSResponse,
  CreateBlockListRequest,
  CreateCallRequest,
  CreateCallResponse,
  CreateChannelTypeRequest,
  CreateChannelTypeResponse,
  CreateCommandRequest,
  CreateCommandResponse,
  CreateDeviceRequest,
  CreateExternalStorageRequest,
  CreateExternalStorageResponse,
  CreateGuestRequest,
  CreateGuestResponse,
  CreateImportRequest,
  CreateImportResponse,
  CreateImportURLRequest,
  CreateImportURLResponse,
  CreatePollOptionRequest,
  CreatePollRequest,
  CreateRoleRequest,
  CreateRoleResponse,
  DeactivateUserRequest,
  DeactivateUserResponse,
  DeactivateUsersRequest,
  DeactivateUsersResponse,
  DeleteChannelResponse,
  DeleteChannelsRequest,
  DeleteChannelsResponse,
  DeleteCommandResponse,
  DeleteExternalStorageResponse,
  DeleteMessageResponse,
  DeleteUsersRequest,
  DeleteUsersResponse,
  EventResponse,
  ExportChannelsRequest,
  ExportChannelsResponse,
  ExportUserResponse,
  ExportUsersRequest,
  ExportUsersResponse,
  FileDeleteResponse,
  FileUploadResponse,
  FlagRequest,
  FlagResponse,
  GetApplicationResponse,
  GetBlockListResponse,
  GetBlockedUsersResponse,
  GetCallTokenRequest,
  GetCallTokenResponse,
  GetCommandResponse,
  GetCustomPermissionResponse,
  GetExportChannelsStatusResponse,
  GetImportResponse,
  GetManyMessagesResponse,
  GetMessageResponse,
  GetOGResponse,
  GetRateLimitsResponse,
  GetReactionsResponse,
  GetRepliesResponse,
  GetTaskResponse,
  GetThreadResponse,
  HideChannelRequest,
  HideChannelResponse,
  ImageSize,
  ImageUploadResponse,
  ListBlockListResponse,
  ListChannelTypesResponse,
  ListCommandsResponse,
  ListDevicesResponse,
  ListExternalStorageResponse,
  ListImportsResponse,
  ListPermissionsResponse,
  ListPushProvidersResponse,
  ListRolesResponse,
  MarkChannelsReadRequest,
  MarkReadRequest,
  MarkReadResponse,
  MarkUnreadRequest,
  MembersResponse,
  MessageActionRequest,
  MessageResponse,
  MuteChannelRequest,
  MuteChannelResponse,
  MuteUserRequest,
  MuteUserResponse,
  OnlyUserID,
  PollOptionResponse,
  PollResponse,
  PollVoteResponse,
  PollVotesResponse,
  QueryBannedUsersRequest,
  QueryBannedUsersResponse,
  QueryChannelsRequest,
  QueryChannelsResponse,
  QueryMembersRequest,
  QueryMessageFlagsRequest,
  QueryMessageFlagsResponse,
  QueryMessageHistoryRequest,
  QueryMessageHistoryResponse,
  QueryPollVotesRequest,
  QueryPollsRequest,
  QueryPollsResponse,
  QueryReactionsRequest,
  QueryReactionsResponse,
  QueryThreadsRequest,
  QueryThreadsResponse,
  QueryUsersPayload,
  QueryUsersResponse,
  ReactionRemovalResponse,
  ReactivateUserRequest,
  ReactivateUserResponse,
  ReactivateUsersRequest,
  ReactivateUsersResponse,
  Response,
  RestoreUsersRequest,
  SearchRequest,
  SearchResponse,
  SendEventRequest,
  SendMessageRequest,
  SendMessageResponse,
  SendReactionRequest,
  SendReactionResponse,
  SendUserCustomEventRequest,
  ShowChannelRequest,
  ShowChannelResponse,
  SortParam,
  TranslateMessageRequest,
  TruncateChannelRequest,
  TruncateChannelResponse,
  UnblockUsersRequest,
  UnblockUsersResponse,
  UnmuteChannelRequest,
  UnmuteResponse,
  UnmuteUserRequest,
  UnreadCountsBatchRequest,
  UnreadCountsBatchResponse,
  UpdateAppRequest,
  UpdateBlockListRequest,
  UpdateChannelPartialRequest,
  UpdateChannelPartialResponse,
  UpdateChannelRequest,
  UpdateChannelResponse,
  UpdateChannelTypeRequest,
  UpdateChannelTypeResponse,
  UpdateCommandRequest,
  UpdateCommandResponse,
  UpdateExternalStorageRequest,
  UpdateExternalStorageResponse,
  UpdateMessagePartialRequest,
  UpdateMessagePartialResponse,
  UpdateMessageRequest,
  UpdateMessageResponse,
  UpdatePollOptionRequest,
  UpdatePollPartialRequest,
  UpdatePollRequest,
  UpdateThreadPartialRequest,
  UpdateThreadPartialResponse,
  UpdateUsersPartialRequest,
  UpdateUsersRequest,
  UpdateUsersResponse,
  UpsertPushProviderRequest,
  UpsertPushProviderResponse,
  WrappedUnreadCountsResponse,
} from '../models';

export interface BanOperationRequest {
    banRequest: BanRequest | null;
}

export interface BlockUsersOperationRequest {
    blockUsersRequest: BlockUsersRequest | null;
}

export interface CastPollVoteOperationRequest {
    messageId: string;
    pollId: string;
    castPollVoteRequest: CastPollVoteRequest | null;
}

export interface CheckExternalStorageRequest {
    name: string;
}

export interface CheckPushOperationRequest {
    checkPushRequest: CheckPushRequest | null;
}

export interface CheckSNSOperationRequest {
    checkSNSRequest: CheckSNSRequest | null;
}

export interface CheckSQSOperationRequest {
    checkSQSRequest: CheckSQSRequest | null;
}

export interface CommitMessageRequest {
    id: string;
}

export interface CreateBlockListOperationRequest {
    createBlockListRequest: CreateBlockListRequest | null;
}

export interface CreateCallOperationRequest {
    type: string;
    id: string;
    createCallRequest: CreateCallRequest | null;
}

export interface CreateChannelTypeOperationRequest {
    createChannelTypeRequest: CreateChannelTypeRequest | null;
}

export interface CreateCommandOperationRequest {
    createCommandRequest: CreateCommandRequest | null;
}

export interface CreateDeviceOperationRequest {
    createDeviceRequest: CreateDeviceRequest | null;
}

export interface CreateExternalStorageOperationRequest {
    createExternalStorageRequest: CreateExternalStorageRequest | null;
}

export interface CreateGuestOperationRequest {
    createGuestRequest: CreateGuestRequest | null;
}

export interface CreateImportOperationRequest {
    createImportRequest: CreateImportRequest | null;
}

export interface CreateImportURLOperationRequest {
    createImportURLRequest: CreateImportURLRequest | null;
}

export interface CreatePollOperationRequest {
    createPollRequest: CreatePollRequest | null;
}

export interface CreatePollOptionOperationRequest {
    pollId: string;
    createPollOptionRequest: CreatePollOptionRequest | null;
}

export interface CreateRoleOperationRequest {
    createRoleRequest: CreateRoleRequest | null;
}

export interface DeactivateUserOperationRequest {
    userId: string;
    deactivateUserRequest: DeactivateUserRequest | null;
}

export interface DeactivateUsersOperationRequest {
    deactivateUsersRequest: DeactivateUsersRequest | null;
}

export interface DeleteBlockListRequest {
    name: string;
}

export interface DeleteChannelRequest {
    type: string;
    id: string;
    hardDelete?: boolean;
}

export interface DeleteChannelTypeRequest {
    name: string;
}

export interface DeleteChannelsOperationRequest {
    deleteChannelsRequest: DeleteChannelsRequest | null;
}

export interface DeleteCommandRequest {
    name: string;
}

export interface DeleteDeviceRequest {
    id: string;
    userId?: string;
}

export interface DeleteExternalStorageRequest {
    name: string;
}

export interface DeleteFileRequest {
    type: string;
    id: string;
    url?: string;
}

export interface DeleteImageRequest {
    type: string;
    id: string;
    url?: string;
}

export interface DeleteMessageRequest {
    id: string;
    hard?: boolean;
    deletedBy?: string;
}

export interface DeletePollRequest {
    pollId: string;
    userId?: string;
}

export interface DeletePollOptionRequest {
    pollId: string;
    optionId: string;
    userId?: string;
}

export interface DeletePushProviderRequest {
    type: DeletePushProviderTypeEnum;
    name: string;
}

export interface DeleteReactionRequest {
    id: string;
    type: string;
    userId?: string;
}

export interface DeleteRoleRequest {
    name: string;
}

export interface DeleteUsersOperationRequest {
    deleteUsersRequest: DeleteUsersRequest | null;
}

export interface ExportChannelsOperationRequest {
    exportChannelsRequest: ExportChannelsRequest | null;
}

export interface ExportUserRequest {
    userId: string;
}

export interface ExportUsersOperationRequest {
    exportUsersRequest: ExportUsersRequest | null;
}

export interface FlagOperationRequest {
    flagRequest: FlagRequest | null;
}

export interface GetBlockListRequest {
    name: string;
}

export interface GetBlockedUsersRequest {
    userId?: string;
}

export interface GetCallTokenOperationRequest {
    getCallTokenRequest: GetCallTokenRequest | null;
}

export interface GetCallToken0Request {
    callId: string;
    getCallTokenRequest: GetCallTokenRequest | null;
}

export interface GetChannelTypeRequest {
    name: string;
}

export interface GetCommandRequest {
    name: string;
}

export interface GetExportChannelsStatusRequest {
    id: string;
}

export interface GetImportRequest {
    id: string;
}

export interface GetManyMessagesRequest {
    type: string;
    id: string;
    ids: Array<string>;
}

export interface GetMessageRequest {
    id: string;
    showDeletedMessage?: boolean;
}

export interface GetOGRequest {
    url: string;
}

export interface GetOrCreateChannelRequest {
    type: string;
    id: string;
    channelGetOrCreateRequest: ChannelGetOrCreateRequest | null;
}

export interface GetOrCreateDistinctChannelRequest {
    type: string;
    channelGetOrCreateRequest: ChannelGetOrCreateRequest | null;
}

export interface GetPermissionRequest {
    id: string;
}

export interface GetPollRequest {
    pollId: string;
    userId?: string;
}

export interface GetPollOptionRequest {
    pollId: string;
    optionId: string;
    userId?: string;
}

export interface GetRateLimitsRequest {
    serverSide?: boolean;
    android?: boolean;
    ios?: boolean;
    web?: boolean;
    endpoints?: string;
}

export interface GetReactionsRequest {
    id: string;
    limit?: number;
    offset?: number;
}

export interface GetRepliesRequest {
    parentId: string;
    sort?: Array<SortParam>;
    limit?: number;
    offset?: number;
    idGte?: string;
    idGt?: string;
    idLte?: string;
    idLt?: string;
    createdAtAfterOrEqual?: string;
    createdAtAfter?: string;
    createdAtBeforeOrEqual?: string;
    createdAtBefore?: string;
    idAround?: string;
    createdAtAround?: string;
}

export interface GetTaskRequest {
    id: string;
}

export interface GetThreadRequest {
    messageId: string;
    connectionId?: string;
    replyLimit?: number;
    participantLimit?: number;
    memberLimit?: number;
}

export interface HideChannelOperationRequest {
    type: string;
    id: string;
    hideChannelRequest: HideChannelRequest | null;
}

export interface ListDevicesRequest {
    userId?: string;
}

export interface MarkChannelsReadOperationRequest {
    markChannelsReadRequest: MarkChannelsReadRequest | null;
}

export interface MarkReadOperationRequest {
    type: string;
    id: string;
    markReadRequest: MarkReadRequest | null;
}

export interface MarkUnreadOperationRequest {
    type: string;
    id: string;
    markUnreadRequest: MarkUnreadRequest | null;
}

export interface MuteChannelOperationRequest {
    muteChannelRequest: MuteChannelRequest | null;
}

export interface MuteUserOperationRequest {
    muteUserRequest: MuteUserRequest | null;
}

export interface QueryBannedUsersOperationRequest {
    payload?: QueryBannedUsersRequest;
}

export interface QueryChannelsOperationRequest {
    queryChannelsRequest: QueryChannelsRequest | null;
}

export interface QueryMembersOperationRequest {
    payload?: QueryMembersRequest;
}

export interface QueryMessageFlagsOperationRequest {
    payload?: QueryMessageFlagsRequest;
}

export interface QueryMessageHistoryOperationRequest {
    queryMessageHistoryRequest: QueryMessageHistoryRequest | null;
}

export interface QueryPollVotesOperationRequest {
    pollId: string;
    queryPollVotesRequest: QueryPollVotesRequest | null;
    userId?: string;
}

export interface QueryPollsOperationRequest {
    queryPollsRequest: QueryPollsRequest | null;
    userId?: string;
}

export interface QueryReactionsOperationRequest {
    id: string;
    queryReactionsRequest: QueryReactionsRequest;
}

export interface QueryThreadsOperationRequest {
    queryThreadsRequest: QueryThreadsRequest | null;
}

export interface QueryUsersRequest {
    payload?: QueryUsersPayload;
}

export interface ReactivateUserOperationRequest {
    userId: string;
    reactivateUserRequest: ReactivateUserRequest | null;
}

export interface ReactivateUsersOperationRequest {
    reactivateUsersRequest: ReactivateUsersRequest | null;
}

export interface RemovePollVoteRequest {
    messageId: string;
    pollId: string;
    voteId: string;
    userId?: string;
}

export interface RestoreUsersOperationRequest {
    restoreUsersRequest: RestoreUsersRequest | null;
}

export interface RunMessageActionRequest {
    id: string;
    messageActionRequest: MessageActionRequest | null;
}

export interface SearchOperationRequest {
    payload?: SearchRequest;
}

export interface SendEventOperationRequest {
    type: string;
    id: string;
    sendEventRequest: SendEventRequest | null;
}

export interface SendMessageOperationRequest {
    type: string;
    id: string;
    sendMessageRequest: SendMessageRequest | null;
}

export interface SendReactionOperationRequest {
    id: string;
    sendReactionRequest: SendReactionRequest | null;
}

export interface SendUserCustomEventOperationRequest {
    userId: string;
    sendUserCustomEventRequest: SendUserCustomEventRequest | null;
}

export interface ShowChannelOperationRequest {
    type: string;
    id: string;
    showChannelRequest: ShowChannelRequest | null;
}

export interface TranslateMessageOperationRequest {
    id: string;
    translateMessageRequest: TranslateMessageRequest | null;
}

export interface TruncateChannelOperationRequest {
    type: string;
    id: string;
    truncateChannelRequest: TruncateChannelRequest | null;
}

export interface UnbanRequest {
    targetUserId: string;
    channelCid?: string;
    createdBy?: string;
}

export interface UnblockUsersOperationRequest {
    unblockUsersRequest: UnblockUsersRequest | null;
}

export interface UndeleteMessageRequest {
    id: string;
    updateMessageRequest: UpdateMessageRequest | null;
}

export interface UnmuteChannelOperationRequest {
    unmuteChannelRequest: UnmuteChannelRequest | null;
}

export interface UnmuteUserOperationRequest {
    unmuteUserRequest: UnmuteUserRequest | null;
}

export interface UnreadCountsBatchOperationRequest {
    unreadCountsBatchRequest: UnreadCountsBatchRequest | null;
}

export interface UpdateAppOperationRequest {
    updateAppRequest: UpdateAppRequest | null;
}

export interface UpdateBlockListOperationRequest {
    name: string;
    updateBlockListRequest: UpdateBlockListRequest | null;
}

export interface UpdateChannelOperationRequest {
    type: string;
    id: string;
    updateChannelRequest: UpdateChannelRequest | null;
}

export interface UpdateChannelPartialOperationRequest {
    type: string;
    id: string;
    updateChannelPartialRequest: UpdateChannelPartialRequest | null;
}

export interface UpdateChannelTypeOperationRequest {
    name: string;
    updateChannelTypeRequest: UpdateChannelTypeRequest | null;
}

export interface UpdateCommandOperationRequest {
    name: string;
    updateCommandRequest: UpdateCommandRequest | null;
}

export interface UpdateExternalStorageOperationRequest {
    name: string;
    updateExternalStorageRequest: UpdateExternalStorageRequest | null;
}

export interface UpdateMessageOperationRequest {
    id: string;
    updateMessageRequest: UpdateMessageRequest | null;
}

export interface UpdateMessagePartialOperationRequest {
    id: string;
    updateMessagePartialRequest: UpdateMessagePartialRequest | null;
}

export interface UpdatePollOperationRequest {
    updatePollRequest: UpdatePollRequest | null;
}

export interface UpdatePollOptionOperationRequest {
    pollId: string;
    updatePollOptionRequest: UpdatePollOptionRequest | null;
}

export interface UpdatePollPartialOperationRequest {
    pollId: string;
    updatePollPartialRequest: UpdatePollPartialRequest | null;
}

export interface UpdateThreadPartialOperationRequest {
    messageId: string;
    updateThreadPartialRequest: UpdateThreadPartialRequest | null;
}

export interface UpdateUsersOperationRequest {
    updateUsersRequest: UpdateUsersRequest | null;
}

export interface UpdateUsersPartialOperationRequest {
    updateUsersPartialRequest: UpdateUsersPartialRequest | null;
}

export interface UploadFileRequest {
    type: string;
    id: string;
    file?: string;
    user?: OnlyUserID;
}

export interface UploadImageRequest {
    type: string;
    id: string;
    file?: string;
    uploadSizes?: Array<ImageSize>;
    user?: OnlyUserID;
}

export interface UpsertPushProviderOperationRequest {
    upsertPushProviderRequest: UpsertPushProviderRequest | null;
}

/**
 * 
 */
export class ProductchatApi extends runtime.BaseAPI {

    /**
     * Restricts user activity either in specific channel or globally  Sends events: - user.banned  Required permissions: - BanChannelMember - BanUser 
     * Ban user
     */
    async banRaw(requestParameters: BanOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.banRequest === null || requestParameters.banRequest === undefined) {
            throw new runtime.RequiredError('banRequest','Required parameter requestParameters.banRequest was null or undefined when calling ban.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/moderation/ban`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.banRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Restricts user activity either in specific channel or globally  Sends events: - user.banned  Required permissions: - BanChannelMember - BanUser 
     * Ban user
     */
    async ban(requestParameters: BanOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.banRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Block users 
     * Block user
     */
    async blockUsersRaw(requestParameters: BlockUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockUsersResponse>> {
        if (requestParameters.blockUsersRequest === null || requestParameters.blockUsersRequest === undefined) {
            throw new runtime.RequiredError('blockUsersRequest','Required parameter requestParameters.blockUsersRequest was null or undefined when calling blockUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users/block`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.blockUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Block users 
     * Block user
     */
    async blockUsers(requestParameters: BlockUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockUsersResponse> {
        const response = await this.blockUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Cast a vote on a poll  Sends events: - poll.vote_casted  Required permissions: - CastVote 
     * Cast vote
     */
    async castPollVoteRaw(requestParameters: CastPollVoteOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PollVoteResponse>> {
        if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
            throw new runtime.RequiredError('messageId','Required parameter requestParameters.messageId was null or undefined when calling castPollVote.');
        }

        if (requestParameters.pollId === null || requestParameters.pollId === undefined) {
            throw new runtime.RequiredError('pollId','Required parameter requestParameters.pollId was null or undefined when calling castPollVote.');
        }

        if (requestParameters.castPollVoteRequest === null || requestParameters.castPollVoteRequest === undefined) {
            throw new runtime.RequiredError('castPollVoteRequest','Required parameter requestParameters.castPollVoteRequest was null or undefined when calling castPollVote.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{message_id}/polls/{poll_id}/vote`.replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters.messageId))).replace(`{${"poll_id"}}`, encodeURIComponent(String(requestParameters.pollId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.castPollVoteRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Cast a vote on a poll  Sends events: - poll.vote_casted  Required permissions: - CastVote 
     * Cast vote
     */
    async castPollVote(requestParameters: CastPollVoteOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PollVoteResponse> {
        const response = await this.castPollVoteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  
     * Check External Storage
     */
    async checkExternalStorageRaw(requestParameters: CheckExternalStorageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckExternalStorageResponse>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling checkExternalStorage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/external_storage/{name}/check`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *  
     * Check External Storage
     */
    async checkExternalStorage(requestParameters: CheckExternalStorageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckExternalStorageResponse> {
        const response = await this.checkExternalStorageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sends a test message via push, this is a test endpoint to verify your push settings 
     * Check push
     */
    async checkPushRaw(requestParameters: CheckPushOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckPushResponse>> {
        if (requestParameters.checkPushRequest === null || requestParameters.checkPushRequest === undefined) {
            throw new runtime.RequiredError('checkPushRequest','Required parameter requestParameters.checkPushRequest was null or undefined when calling checkPush.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/check_push`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.checkPushRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sends a test message via push, this is a test endpoint to verify your push settings 
     * Check push
     */
    async checkPush(requestParameters: CheckPushOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckPushResponse> {
        const response = await this.checkPushRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Validates Amazon SNS configuration 
     * Check SNS
     */
    async checkSNSRaw(requestParameters: CheckSNSOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckSNSResponse>> {
        if (requestParameters.checkSNSRequest === null || requestParameters.checkSNSRequest === undefined) {
            throw new runtime.RequiredError('checkSNSRequest','Required parameter requestParameters.checkSNSRequest was null or undefined when calling checkSNS.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/check_sns`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.checkSNSRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Validates Amazon SNS configuration 
     * Check SNS
     */
    async checkSNS(requestParameters: CheckSNSOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckSNSResponse> {
        const response = await this.checkSNSRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Validates Amazon SQS credentials 
     * Check SQS
     */
    async checkSQSRaw(requestParameters: CheckSQSOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckSQSResponse>> {
        if (requestParameters.checkSQSRequest === null || requestParameters.checkSQSRequest === undefined) {
            throw new runtime.RequiredError('checkSQSRequest','Required parameter requestParameters.checkSQSRequest was null or undefined when calling checkSQS.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/check_sqs`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.checkSQSRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Validates Amazon SQS credentials 
     * Check SQS
     */
    async checkSQS(requestParameters: CheckSQSOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckSQSResponse> {
        const response = await this.checkSQSRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Commits a pending message, which will make it visible in the channel  Sends events: - message.new - message.updated 
     * Commit message
     */
    async commitMessageRaw(requestParameters: CommitMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling commitMessage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}/commit`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Commits a pending message, which will make it visible in the channel  Sends events: - message.new - message.updated 
     * Commit message
     */
    async commitMessage(requestParameters: CommitMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageResponse> {
        const response = await this.commitMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new application blocklist, once created the blocklist can be used by any channel type 
     * Create block list
     */
    async createBlockListRaw(requestParameters: CreateBlockListOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.createBlockListRequest === null || requestParameters.createBlockListRequest === undefined) {
            throw new runtime.RequiredError('createBlockListRequest','Required parameter requestParameters.createBlockListRequest was null or undefined when calling createBlockList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/blocklists`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createBlockListRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates a new application blocklist, once created the blocklist can be used by any channel type 
     * Create block list
     */
    async createBlockList(requestParameters: CreateBlockListOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.createBlockListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a call  Required permissions: - CreateCall - ReadChannel 
     * Create a call
     */
    async createCallRaw(requestParameters: CreateCallOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateCallResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling createCall.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling createCall.');
        }

        if (requestParameters.createCallRequest === null || requestParameters.createCallRequest === undefined) {
            throw new runtime.RequiredError('createCallRequest','Required parameter requestParameters.createCallRequest was null or undefined when calling createCall.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/call`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createCallRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates a call  Required permissions: - CreateCall - ReadChannel 
     * Create a call
     */
    async createCall(requestParameters: CreateCallOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateCallResponse> {
        const response = await this.createCallRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates new channel type 
     * Create channel type
     */
    async createChannelTypeRaw(requestParameters: CreateChannelTypeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateChannelTypeResponse>> {
        if (requestParameters.createChannelTypeRequest === null || requestParameters.createChannelTypeRequest === undefined) {
            throw new runtime.RequiredError('createChannelTypeRequest','Required parameter requestParameters.createChannelTypeRequest was null or undefined when calling createChannelType.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channeltypes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createChannelTypeRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates new channel type 
     * Create channel type
     */
    async createChannelType(requestParameters: CreateChannelTypeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateChannelTypeResponse> {
        const response = await this.createChannelTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates custom chat command 
     * Create command
     */
    async createCommandRaw(requestParameters: CreateCommandOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateCommandResponse>> {
        if (requestParameters.createCommandRequest === null || requestParameters.createCommandRequest === undefined) {
            throw new runtime.RequiredError('createCommandRequest','Required parameter requestParameters.createCommandRequest was null or undefined when calling createCommand.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/commands`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createCommandRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates custom chat command 
     * Create command
     */
    async createCommand(requestParameters: CreateCommandOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateCommandResponse> {
        const response = await this.createCommandRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Adds a new device to a user, if the same device already exists the call will have no effect 
     * Create device
     */
    async createDeviceRaw(requestParameters: CreateDeviceOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.createDeviceRequest === null || requestParameters.createDeviceRequest === undefined) {
            throw new runtime.RequiredError('createDeviceRequest','Required parameter requestParameters.createDeviceRequest was null or undefined when calling createDevice.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/devices`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createDeviceRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Adds a new device to a user, if the same device already exists the call will have no effect 
     * Create device
     */
    async createDevice(requestParameters: CreateDeviceOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.createDeviceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates new external storage 
     * Create external storage
     */
    async createExternalStorageRaw(requestParameters: CreateExternalStorageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateExternalStorageResponse>> {
        if (requestParameters.createExternalStorageRequest === null || requestParameters.createExternalStorageRequest === undefined) {
            throw new runtime.RequiredError('createExternalStorageRequest','Required parameter requestParameters.createExternalStorageRequest was null or undefined when calling createExternalStorage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/external_storage`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createExternalStorageRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates new external storage 
     * Create external storage
     */
    async createExternalStorage(requestParameters: CreateExternalStorageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateExternalStorageResponse> {
        const response = await this.createExternalStorageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  
     * Create Guest
     */
    async createGuestRaw(requestParameters: CreateGuestOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateGuestResponse>> {
        if (requestParameters.createGuestRequest === null || requestParameters.createGuestRequest === undefined) {
            throw new runtime.RequiredError('createGuestRequest','Required parameter requestParameters.createGuestRequest was null or undefined when calling createGuest.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/guest`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createGuestRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *  
     * Create Guest
     */
    async createGuest(requestParameters: CreateGuestOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateGuestResponse> {
        const response = await this.createGuestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new import 
     * Create import
     */
    async createImportRaw(requestParameters: CreateImportOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateImportResponse>> {
        if (requestParameters.createImportRequest === null || requestParameters.createImportRequest === undefined) {
            throw new runtime.RequiredError('createImportRequest','Required parameter requestParameters.createImportRequest was null or undefined when calling createImport.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/imports`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createImportRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates a new import 
     * Create import
     */
    async createImport(requestParameters: CreateImportOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateImportResponse> {
        const response = await this.createImportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new import URL 
     * Create import URL
     */
    async createImportURLRaw(requestParameters: CreateImportURLOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateImportURLResponse>> {
        if (requestParameters.createImportURLRequest === null || requestParameters.createImportURLRequest === undefined) {
            throw new runtime.RequiredError('createImportURLRequest','Required parameter requestParameters.createImportURLRequest was null or undefined when calling createImportURL.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/import_urls`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createImportURLRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates a new import URL 
     * Create import URL
     */
    async createImportURL(requestParameters: CreateImportURLOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateImportURLResponse> {
        const response = await this.createImportURLRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new poll  Required permissions: - CreatePoll 
     * Create poll
     */
    async createPollRaw(requestParameters: CreatePollOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PollResponse>> {
        if (requestParameters.createPollRequest === null || requestParameters.createPollRequest === undefined) {
            throw new runtime.RequiredError('createPollRequest','Required parameter requestParameters.createPollRequest was null or undefined when calling createPoll.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/polls`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createPollRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates a new poll  Required permissions: - CreatePoll 
     * Create poll
     */
    async createPoll(requestParameters: CreatePollOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PollResponse> {
        const response = await this.createPollRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a poll option  Sends events: - poll.updated  Required permissions: - CastVote - UpdatePoll 
     * Create poll option
     */
    async createPollOptionRaw(requestParameters: CreatePollOptionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PollOptionResponse>> {
        if (requestParameters.pollId === null || requestParameters.pollId === undefined) {
            throw new runtime.RequiredError('pollId','Required parameter requestParameters.pollId was null or undefined when calling createPollOption.');
        }

        if (requestParameters.createPollOptionRequest === null || requestParameters.createPollOptionRequest === undefined) {
            throw new runtime.RequiredError('createPollOptionRequest','Required parameter requestParameters.createPollOptionRequest was null or undefined when calling createPollOption.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/polls/{poll_id}/options`.replace(`{${"poll_id"}}`, encodeURIComponent(String(requestParameters.pollId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createPollOptionRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates a poll option  Sends events: - poll.updated  Required permissions: - CastVote - UpdatePoll 
     * Create poll option
     */
    async createPollOption(requestParameters: CreatePollOptionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PollOptionResponse> {
        const response = await this.createPollOptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates custom role 
     * Create role
     */
    async createRoleRaw(requestParameters: CreateRoleOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateRoleResponse>> {
        if (requestParameters.createRoleRequest === null || requestParameters.createRoleRequest === undefined) {
            throw new runtime.RequiredError('createRoleRequest','Required parameter requestParameters.createRoleRequest was null or undefined when calling createRole.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/roles`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createRoleRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates custom role 
     * Create role
     */
    async createRole(requestParameters: CreateRoleOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateRoleResponse> {
        const response = await this.createRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deactivates user with possibility to activate it back  Sends events: - user.deactivated 
     * Deactivate user
     */
    async deactivateUserRaw(requestParameters: DeactivateUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeactivateUserResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling deactivateUser.');
        }

        if (requestParameters.deactivateUserRequest === null || requestParameters.deactivateUserRequest === undefined) {
            throw new runtime.RequiredError('deactivateUserRequest','Required parameter requestParameters.deactivateUserRequest was null or undefined when calling deactivateUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users/{user_id}/deactivate`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.deactivateUserRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deactivates user with possibility to activate it back  Sends events: - user.deactivated 
     * Deactivate user
     */
    async deactivateUser(requestParameters: DeactivateUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeactivateUserResponse> {
        const response = await this.deactivateUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deactivate users in batches  Sends events: - user.deactivated 
     * Deactivate users
     */
    async deactivateUsersRaw(requestParameters: DeactivateUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeactivateUsersResponse>> {
        if (requestParameters.deactivateUsersRequest === null || requestParameters.deactivateUsersRequest === undefined) {
            throw new runtime.RequiredError('deactivateUsersRequest','Required parameter requestParameters.deactivateUsersRequest was null or undefined when calling deactivateUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users/deactivate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.deactivateUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deactivate users in batches  Sends events: - user.deactivated 
     * Deactivate users
     */
    async deactivateUsers(requestParameters: DeactivateUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeactivateUsersResponse> {
        const response = await this.deactivateUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes previously created application blocklist 
     * Delete block list
     */
    async deleteBlockListRaw(requestParameters: DeleteBlockListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteBlockList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/blocklists/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes previously created application blocklist 
     * Delete block list
     */
    async deleteBlockList(requestParameters: DeleteBlockListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.deleteBlockListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes channel  Sends events: - channel.deleted  Required permissions: - DeleteChannel 
     * Delete channel
     */
    async deleteChannelRaw(requestParameters: DeleteChannelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteChannelResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling deleteChannel.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteChannel.');
        }

        const queryParameters: any = {};

        if (requestParameters.hardDelete !== undefined) {
            queryParameters['hard_delete'] = requestParameters.hardDelete;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes channel  Sends events: - channel.deleted  Required permissions: - DeleteChannel 
     * Delete channel
     */
    async deleteChannel(requestParameters: DeleteChannelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteChannelResponse> {
        const response = await this.deleteChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes channel type 
     * Delete channel type
     */
    async deleteChannelTypeRaw(requestParameters: DeleteChannelTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteChannelType.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channeltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes channel type 
     * Delete channel type
     */
    async deleteChannelType(requestParameters: DeleteChannelTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.deleteChannelTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Allows to delete several channels at once asynchronously  Sends events: - channel.deleted  Required permissions: - DeleteChannel 
     * Deletes channels asynchronously
     */
    async deleteChannelsRaw(requestParameters: DeleteChannelsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteChannelsResponse>> {
        if (requestParameters.deleteChannelsRequest === null || requestParameters.deleteChannelsRequest === undefined) {
            throw new runtime.RequiredError('deleteChannelsRequest','Required parameter requestParameters.deleteChannelsRequest was null or undefined when calling deleteChannels.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/delete`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.deleteChannelsRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Allows to delete several channels at once asynchronously  Sends events: - channel.deleted  Required permissions: - DeleteChannel 
     * Deletes channels asynchronously
     */
    async deleteChannels(requestParameters: DeleteChannelsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteChannelsResponse> {
        const response = await this.deleteChannelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes custom chat command 
     * Delete command
     */
    async deleteCommandRaw(requestParameters: DeleteCommandRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteCommandResponse>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCommand.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/commands/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes custom chat command 
     * Delete command
     */
    async deleteCommand(requestParameters: DeleteCommandRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteCommandResponse> {
        const response = await this.deleteCommandRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes one device 
     * Delete device
     */
    async deleteDeviceRaw(requestParameters: DeleteDeviceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteDevice.');
        }

        const queryParameters: any = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/devices`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes one device 
     * Delete device
     */
    async deleteDevice(requestParameters: DeleteDeviceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.deleteDeviceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes external storage 
     * Delete external storage
     */
    async deleteExternalStorageRaw(requestParameters: DeleteExternalStorageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteExternalStorageResponse>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteExternalStorage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/external_storage/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes external storage 
     * Delete external storage
     */
    async deleteExternalStorage(requestParameters: DeleteExternalStorageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteExternalStorageResponse> {
        const response = await this.deleteExternalStorageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes previously uploaded file  Required permissions: - DeleteAttachment 
     * Delete file
     */
    async deleteFileRaw(requestParameters: DeleteFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FileDeleteResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling deleteFile.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteFile.');
        }

        const queryParameters: any = {};

        if (requestParameters.url !== undefined) {
            queryParameters['url'] = requestParameters.url;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/file`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes previously uploaded file  Required permissions: - DeleteAttachment 
     * Delete file
     */
    async deleteFile(requestParameters: DeleteFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FileDeleteResponse> {
        const response = await this.deleteFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes previously uploaded image  Required permissions: - DeleteAttachment 
     * Delete image
     */
    async deleteImageRaw(requestParameters: DeleteImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FileDeleteResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling deleteImage.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteImage.');
        }

        const queryParameters: any = {};

        if (requestParameters.url !== undefined) {
            queryParameters['url'] = requestParameters.url;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/image`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes previously uploaded image  Required permissions: - DeleteAttachment 
     * Delete image
     */
    async deleteImage(requestParameters: DeleteImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FileDeleteResponse> {
        const response = await this.deleteImageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes message  Sends events: - message.deleted  Required permissions: - DeleteMessage 
     * Delete message
     */
    async deleteMessageRaw(requestParameters: DeleteMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteMessageResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteMessage.');
        }

        const queryParameters: any = {};

        if (requestParameters.hard !== undefined) {
            queryParameters['hard'] = requestParameters.hard;
        }

        if (requestParameters.deletedBy !== undefined) {
            queryParameters['deleted_by'] = requestParameters.deletedBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes message  Sends events: - message.deleted  Required permissions: - DeleteMessage 
     * Delete message
     */
    async deleteMessage(requestParameters: DeleteMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteMessageResponse> {
        const response = await this.deleteMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes a poll  Sends events: - poll.deleted  Required permissions: - DeletePoll 
     * Delete poll
     */
    async deletePollRaw(requestParameters: DeletePollRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.pollId === null || requestParameters.pollId === undefined) {
            throw new runtime.RequiredError('pollId','Required parameter requestParameters.pollId was null or undefined when calling deletePoll.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/polls/{poll_id}`.replace(`{${"poll_id"}}`, encodeURIComponent(String(requestParameters.pollId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes a poll  Sends events: - poll.deleted  Required permissions: - DeletePoll 
     * Delete poll
     */
    async deletePoll(requestParameters: DeletePollRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.deletePollRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes a poll option  Sends events: - poll.updated  Required permissions: - UpdatePoll 
     * Delete poll option
     */
    async deletePollOptionRaw(requestParameters: DeletePollOptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.pollId === null || requestParameters.pollId === undefined) {
            throw new runtime.RequiredError('pollId','Required parameter requestParameters.pollId was null or undefined when calling deletePollOption.');
        }

        if (requestParameters.optionId === null || requestParameters.optionId === undefined) {
            throw new runtime.RequiredError('optionId','Required parameter requestParameters.optionId was null or undefined when calling deletePollOption.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/polls/{poll_id}/options/{option_id}`.replace(`{${"poll_id"}}`, encodeURIComponent(String(requestParameters.pollId))).replace(`{${"option_id"}}`, encodeURIComponent(String(requestParameters.optionId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes a poll option  Sends events: - poll.updated  Required permissions: - UpdatePoll 
     * Delete poll option
     */
    async deletePollOption(requestParameters: DeletePollOptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.deletePollOptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a push provider from v2 with multi bundle/package support. v1 isn\'t supported in this endpoint 
     * Delete a push provider
     */
    async deletePushProviderRaw(requestParameters: DeletePushProviderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling deletePushProvider.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deletePushProvider.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/push_providers/{type}/{name}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Delete a push provider from v2 with multi bundle/package support. v1 isn\'t supported in this endpoint 
     * Delete a push provider
     */
    async deletePushProvider(requestParameters: DeletePushProviderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.deletePushProviderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Removes user reaction from the message  Sends events: - reaction.deleted  Required permissions: - DeleteReaction 
     * Delete reaction
     */
    async deleteReactionRaw(requestParameters: DeleteReactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReactionRemovalResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteReaction.');
        }

        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling deleteReaction.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}/reaction/{type}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Removes user reaction from the message  Sends events: - reaction.deleted  Required permissions: - DeleteReaction 
     * Delete reaction
     */
    async deleteReaction(requestParameters: DeleteReactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReactionRemovalResponse> {
        const response = await this.deleteReactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes custom role 
     * Delete role
     */
    async deleteRoleRaw(requestParameters: DeleteRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteRole.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/roles/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes custom role 
     * Delete role
     */
    async deleteRole(requestParameters: DeleteRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.deleteRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes users and optionally all their belongings asynchronously.  Sends events: - channel.deleted - user.deleted 
     * Delete Users
     */
    async deleteUsersRaw(requestParameters: DeleteUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteUsersResponse>> {
        if (requestParameters.deleteUsersRequest === null || requestParameters.deleteUsersRequest === undefined) {
            throw new runtime.RequiredError('deleteUsersRequest','Required parameter requestParameters.deleteUsersRequest was null or undefined when calling deleteUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users/delete`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.deleteUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes users and optionally all their belongings asynchronously.  Sends events: - channel.deleted - user.deleted 
     * Delete Users
     */
    async deleteUsers(requestParameters: DeleteUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteUsersResponse> {
        const response = await this.deleteUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Exports channel data to JSON file 
     * Export channels
     */
    async exportChannelsRaw(requestParameters: ExportChannelsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportChannelsResponse>> {
        if (requestParameters.exportChannelsRequest === null || requestParameters.exportChannelsRequest === undefined) {
            throw new runtime.RequiredError('exportChannelsRequest','Required parameter requestParameters.exportChannelsRequest was null or undefined when calling exportChannels.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/export_channels`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.exportChannelsRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Exports channel data to JSON file 
     * Export channels
     */
    async exportChannels(requestParameters: ExportChannelsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportChannelsResponse> {
        const response = await this.exportChannelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Exports the user\'s profile, reactions and messages. Raises an error if a user has more than 10k messages or reactions 
     * Export user
     */
    async exportUserRaw(requestParameters: ExportUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportUserResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling exportUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users/{user_id}/export`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Exports the user\'s profile, reactions and messages. Raises an error if a user has more than 10k messages or reactions 
     * Export user
     */
    async exportUser(requestParameters: ExportUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportUserResponse> {
        const response = await this.exportUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Exports user profile, reactions and messages for list of given users 
     * Export users
     */
    async exportUsersRaw(requestParameters: ExportUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportUsersResponse>> {
        if (requestParameters.exportUsersRequest === null || requestParameters.exportUsersRequest === undefined) {
            throw new runtime.RequiredError('exportUsersRequest','Required parameter requestParameters.exportUsersRequest was null or undefined when calling exportUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/export/users`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.exportUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Exports user profile, reactions and messages for list of given users 
     * Export users
     */
    async exportUsers(requestParameters: ExportUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportUsersResponse> {
        const response = await this.exportUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser 
     * Flag
     */
    async flagRaw(requestParameters: FlagOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FlagResponse>> {
        if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {
            throw new runtime.RequiredError('flagRequest','Required parameter requestParameters.flagRequest was null or undefined when calling flag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/moderation/flag`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.flagRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser 
     * Flag
     */
    async flag(requestParameters: FlagOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FlagResponse> {
        const response = await this.flagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This Method returns the application settings 
     * Get App Settings
     */
    async getAppRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetApplicationResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/app`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * This Method returns the application settings 
     * Get App Settings
     */
    async getApp(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetApplicationResponse> {
        const response = await this.getAppRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns block list by given name 
     * Get block list
     */
    async getBlockListRaw(requestParameters: GetBlockListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetBlockListResponse>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getBlockList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/blocklists/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns block list by given name 
     * Get block list
     */
    async getBlockList(requestParameters: GetBlockListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetBlockListResponse> {
        const response = await this.getBlockListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get list of blocked Users 
     * Get list of blocked Users
     */
    async getBlockedUsersRaw(requestParameters: GetBlockedUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetBlockedUsersResponse>> {
        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users/block`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get list of blocked Users 
     * Get list of blocked Users
     */
    async getBlockedUsers(requestParameters: GetBlockedUsersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetBlockedUsersResponse> {
        const response = await this.getBlockedUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the token to join a call  Required permissions: - JoinCall - ReadChannel 
     * Get Call Token
     */
    async getCallTokenRaw(requestParameters: GetCallTokenOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCallTokenResponse>> {
        if (requestParameters.getCallTokenRequest === null || requestParameters.getCallTokenRequest === undefined) {
            throw new runtime.RequiredError('getCallTokenRequest','Required parameter requestParameters.getCallTokenRequest was null or undefined when calling getCallToken.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/calls`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.getCallTokenRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the token to join a call  Required permissions: - JoinCall - ReadChannel 
     * Get Call Token
     */
    async getCallToken(requestParameters: GetCallTokenOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCallTokenResponse> {
        const response = await this.getCallTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the token to join a call  Required permissions: - JoinCall - ReadChannel 
     * Get Call Token
     */
    async getCallToken_1Raw(requestParameters: GetCallToken0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCallTokenResponse>> {
        if (requestParameters.callId === null || requestParameters.callId === undefined) {
            throw new runtime.RequiredError('callId','Required parameter requestParameters.callId was null or undefined when calling getCallToken_1.');
        }

        if (requestParameters.getCallTokenRequest === null || requestParameters.getCallTokenRequest === undefined) {
            throw new runtime.RequiredError('getCallTokenRequest','Required parameter requestParameters.getCallTokenRequest was null or undefined when calling getCallToken_1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/calls/{call_id}`.replace(`{${"call_id"}}`, encodeURIComponent(String(requestParameters.callId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.getCallTokenRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the token to join a call  Required permissions: - JoinCall - ReadChannel 
     * Get Call Token
     */
    async getCallToken_1(requestParameters: GetCallToken0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCallTokenResponse> {
        const response = await this.getCallToken_1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets channel type 
     * Get channel type
     */
    async getChannelTypeRaw(requestParameters: GetChannelTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getChannelType.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channeltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets channel type 
     * Get channel type
     */
    async getChannelType(requestParameters: GetChannelTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.getChannelTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns custom command by its name 
     * Get command
     */
    async getCommandRaw(requestParameters: GetCommandRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCommandResponse>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getCommand.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/commands/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns custom command by its name 
     * Get command
     */
    async getCommand(requestParameters: GetCommandRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCommandResponse> {
        const response = await this.getCommandRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  
     * Export channels status
     */
    async getExportChannelsStatusRaw(requestParameters: GetExportChannelsStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetExportChannelsStatusResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getExportChannelsStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/export_channels/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *  
     * Export channels status
     */
    async getExportChannelsStatus(requestParameters: GetExportChannelsStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetExportChannelsStatusResponse> {
        const response = await this.getExportChannelsStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets an import 
     * Get import
     */
    async getImportRaw(requestParameters: GetImportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetImportResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getImport.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/imports/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets an import 
     * Get import
     */
    async getImport(requestParameters: GetImportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetImportResponse> {
        const response = await this.getImportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns list messages found by IDs  Required permissions: - ReadChannel 
     * Get many messages
     */
    async getManyMessagesRaw(requestParameters: GetManyMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetManyMessagesResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling getManyMessages.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getManyMessages.');
        }

        if (requestParameters.ids === null || requestParameters.ids === undefined) {
            throw new runtime.RequiredError('ids','Required parameter requestParameters.ids was null or undefined when calling getManyMessages.');
        }

        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters['ids'] = requestParameters.ids;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/messages`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns list messages found by IDs  Required permissions: - ReadChannel 
     * Get many messages
     */
    async getManyMessages(requestParameters: GetManyMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetManyMessagesResponse> {
        const response = await this.getManyMessagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns message by ID  Required permissions: - ReadChannel 
     * Get message
     */
    async getMessageRaw(requestParameters: GetMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetMessageResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getMessage.');
        }

        const queryParameters: any = {};

        if (requestParameters.showDeletedMessage !== undefined) {
            queryParameters['show_deleted_message'] = requestParameters.showDeletedMessage;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns message by ID  Required permissions: - ReadChannel 
     * Get message
     */
    async getMessage(requestParameters: GetMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetMessageResponse> {
        const response = await this.getMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get an OpenGraph attachment for a link 
     * Get OG
     */
    async getOGRaw(requestParameters: GetOGRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetOGResponse>> {
        if (requestParameters.url === null || requestParameters.url === undefined) {
            throw new runtime.RequiredError('url','Required parameter requestParameters.url was null or undefined when calling getOG.');
        }

        const queryParameters: any = {};

        if (requestParameters.url !== undefined) {
            queryParameters['url'] = requestParameters.url;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/og`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get an OpenGraph attachment for a link 
     * Get OG
     */
    async getOG(requestParameters: GetOGRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetOGResponse> {
        const response = await this.getOGRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This Method creates a channel or returns an existing one with matching attributes  Sends events: - channel.created - member.added - member.removed - member.updated - user.watching.start 
     * Get or create channel
     */
    async getOrCreateChannelRaw(requestParameters: GetOrCreateChannelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChannelStateResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling getOrCreateChannel.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getOrCreateChannel.');
        }

        if (requestParameters.channelGetOrCreateRequest === null || requestParameters.channelGetOrCreateRequest === undefined) {
            throw new runtime.RequiredError('channelGetOrCreateRequest','Required parameter requestParameters.channelGetOrCreateRequest was null or undefined when calling getOrCreateChannel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/query`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.channelGetOrCreateRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * This Method creates a channel or returns an existing one with matching attributes  Sends events: - channel.created - member.added - member.removed - member.updated - user.watching.start 
     * Get or create channel
     */
    async getOrCreateChannel(requestParameters: GetOrCreateChannelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChannelStateResponse> {
        const response = await this.getOrCreateChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This Method creates a channel or returns an existing one with matching attributes  Sends events: - channel.created - member.added - member.removed - member.updated - user.watching.start 
     * Get or create channel
     */
    async getOrCreateDistinctChannelRaw(requestParameters: GetOrCreateDistinctChannelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChannelStateResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling getOrCreateDistinctChannel.');
        }

        if (requestParameters.channelGetOrCreateRequest === null || requestParameters.channelGetOrCreateRequest === undefined) {
            throw new runtime.RequiredError('channelGetOrCreateRequest','Required parameter requestParameters.channelGetOrCreateRequest was null or undefined when calling getOrCreateDistinctChannel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/query`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.channelGetOrCreateRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * This Method creates a channel or returns an existing one with matching attributes  Sends events: - channel.created - member.added - member.removed - member.updated - user.watching.start 
     * Get or create channel
     */
    async getOrCreateDistinctChannel(requestParameters: GetOrCreateDistinctChannelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChannelStateResponse> {
        const response = await this.getOrCreateDistinctChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets custom permission 
     * Get permission
     */
    async getPermissionRaw(requestParameters: GetPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCustomPermissionResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getPermission.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/permissions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets custom permission 
     * Get permission
     */
    async getPermission(requestParameters: GetPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCustomPermissionResponse> {
        const response = await this.getPermissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a poll 
     * Get poll
     */
    async getPollRaw(requestParameters: GetPollRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PollResponse>> {
        if (requestParameters.pollId === null || requestParameters.pollId === undefined) {
            throw new runtime.RequiredError('pollId','Required parameter requestParameters.pollId was null or undefined when calling getPoll.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/polls/{poll_id}`.replace(`{${"poll_id"}}`, encodeURIComponent(String(requestParameters.pollId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves a poll 
     * Get poll
     */
    async getPoll(requestParameters: GetPollRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PollResponse> {
        const response = await this.getPollRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a poll option 
     * Get poll option
     */
    async getPollOptionRaw(requestParameters: GetPollOptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PollOptionResponse>> {
        if (requestParameters.pollId === null || requestParameters.pollId === undefined) {
            throw new runtime.RequiredError('pollId','Required parameter requestParameters.pollId was null or undefined when calling getPollOption.');
        }

        if (requestParameters.optionId === null || requestParameters.optionId === undefined) {
            throw new runtime.RequiredError('optionId','Required parameter requestParameters.optionId was null or undefined when calling getPollOption.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/polls/{poll_id}/options/{option_id}`.replace(`{${"poll_id"}}`, encodeURIComponent(String(requestParameters.pollId))).replace(`{${"option_id"}}`, encodeURIComponent(String(requestParameters.optionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves a poll option 
     * Get poll option
     */
    async getPollOption(requestParameters: GetPollOptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PollOptionResponse> {
        const response = await this.getPollOptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get rate limits usage and quotas 
     * Get rate limits
     */
    async getRateLimitsRaw(requestParameters: GetRateLimitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRateLimitsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.serverSide !== undefined) {
            queryParameters['server_side'] = requestParameters.serverSide;
        }

        if (requestParameters.android !== undefined) {
            queryParameters['android'] = requestParameters.android;
        }

        if (requestParameters.ios !== undefined) {
            queryParameters['ios'] = requestParameters.ios;
        }

        if (requestParameters.web !== undefined) {
            queryParameters['web'] = requestParameters.web;
        }

        if (requestParameters.endpoints !== undefined) {
            queryParameters['endpoints'] = requestParameters.endpoints;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/rate_limits`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get rate limits usage and quotas 
     * Get rate limits
     */
    async getRateLimits(requestParameters: GetRateLimitsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRateLimitsResponse> {
        const response = await this.getRateLimitsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns list of reactions of specific message  Required permissions: - ReadChannel 
     * Get reactions
     */
    async getReactionsRaw(requestParameters: GetReactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetReactionsResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getReactions.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}/reactions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns list of reactions of specific message  Required permissions: - ReadChannel 
     * Get reactions
     */
    async getReactions(requestParameters: GetReactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetReactionsResponse> {
        const response = await this.getReactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns replies (thread) of the message  Required permissions: - ReadChannel 
     * Get replies
     */
    async getRepliesRaw(requestParameters: GetRepliesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRepliesResponse>> {
        if (requestParameters.parentId === null || requestParameters.parentId === undefined) {
            throw new runtime.RequiredError('parentId','Required parameter requestParameters.parentId was null or undefined when calling getReplies.');
        }

        const queryParameters: any = {};

        if (requestParameters.sort) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.idGte !== undefined) {
            queryParameters['id_gte'] = requestParameters.idGte;
        }

        if (requestParameters.idGt !== undefined) {
            queryParameters['id_gt'] = requestParameters.idGt;
        }

        if (requestParameters.idLte !== undefined) {
            queryParameters['id_lte'] = requestParameters.idLte;
        }

        if (requestParameters.idLt !== undefined) {
            queryParameters['id_lt'] = requestParameters.idLt;
        }

        if (requestParameters.createdAtAfterOrEqual !== undefined) {
            queryParameters['created_at_after_or_equal'] = requestParameters.createdAtAfterOrEqual;
        }

        if (requestParameters.createdAtAfter !== undefined) {
            queryParameters['created_at_after'] = requestParameters.createdAtAfter;
        }

        if (requestParameters.createdAtBeforeOrEqual !== undefined) {
            queryParameters['created_at_before_or_equal'] = requestParameters.createdAtBeforeOrEqual;
        }

        if (requestParameters.createdAtBefore !== undefined) {
            queryParameters['created_at_before'] = requestParameters.createdAtBefore;
        }

        if (requestParameters.idAround !== undefined) {
            queryParameters['id_around'] = requestParameters.idAround;
        }

        if (requestParameters.createdAtAround !== undefined) {
            queryParameters['created_at_around'] = requestParameters.createdAtAround;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{parent_id}/replies`.replace(`{${"parent_id"}}`, encodeURIComponent(String(requestParameters.parentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns replies (thread) of the message  Required permissions: - ReadChannel 
     * Get replies
     */
    async getReplies(requestParameters: GetRepliesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRepliesResponse> {
        const response = await this.getRepliesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets status of a task 
     * Get status of a task
     */
    async getTaskRaw(requestParameters: GetTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetTaskResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getTask.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/tasks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets status of a task 
     * Get status of a task
     */
    async getTask(requestParameters: GetTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetTaskResponse> {
        const response = await this.getTaskRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a specific thread  Required permissions: - ReadChannel 
     * Get Thread
     */
    async getThreadRaw(requestParameters: GetThreadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetThreadResponse>> {
        if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
            throw new runtime.RequiredError('messageId','Required parameter requestParameters.messageId was null or undefined when calling getThread.');
        }

        const queryParameters: any = {};

        if (requestParameters.connectionId !== undefined) {
            queryParameters['connection_id'] = requestParameters.connectionId;
        }

        if (requestParameters.replyLimit !== undefined) {
            queryParameters['reply_limit'] = requestParameters.replyLimit;
        }

        if (requestParameters.participantLimit !== undefined) {
            queryParameters['participant_limit'] = requestParameters.participantLimit;
        }

        if (requestParameters.memberLimit !== undefined) {
            queryParameters['member_limit'] = requestParameters.memberLimit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/threads/{message_id}`.replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters.messageId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Return a specific thread  Required permissions: - ReadChannel 
     * Get Thread
     */
    async getThread(requestParameters: GetThreadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetThreadResponse> {
        const response = await this.getThreadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Marks channel as hidden for current user  Sends events: - channel.hidden  Required permissions: - ReadChannel 
     * Hide channel
     */
    async hideChannelRaw(requestParameters: HideChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HideChannelResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling hideChannel.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling hideChannel.');
        }

        if (requestParameters.hideChannelRequest === null || requestParameters.hideChannelRequest === undefined) {
            throw new runtime.RequiredError('hideChannelRequest','Required parameter requestParameters.hideChannelRequest was null or undefined when calling hideChannel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/hide`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.hideChannelRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Marks channel as hidden for current user  Sends events: - channel.hidden  Required permissions: - ReadChannel 
     * Hide channel
     */
    async hideChannel(requestParameters: HideChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HideChannelResponse> {
        const response = await this.hideChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all available block lists 
     * List block lists
     */
    async listBlockListsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListBlockListResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/blocklists`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns all available block lists 
     * List block lists
     */
    async listBlockLists(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListBlockListResponse> {
        const response = await this.listBlockListsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Lists all available channel types 
     * List channel types
     */
    async listChannelTypesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListChannelTypesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channeltypes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Lists all available channel types 
     * List channel types
     */
    async listChannelTypes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListChannelTypesResponse> {
        const response = await this.listChannelTypesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns all custom commands 
     * List commands
     */
    async listCommandsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListCommandsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/commands`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns all custom commands 
     * List commands
     */
    async listCommands(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListCommandsResponse> {
        const response = await this.listCommandsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns all available devices 
     * List devices
     */
    async listDevicesRaw(requestParameters: ListDevicesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListDevicesResponse>> {
        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/devices`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns all available devices 
     * List devices
     */
    async listDevices(requestParameters: ListDevicesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListDevicesResponse> {
        const response = await this.listDevicesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists external storage 
     * List external storage
     */
    async listExternalStorageRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListExternalStorageResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/external_storage`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Lists external storage 
     * List external storage
     */
    async listExternalStorage(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListExternalStorageResponse> {
        const response = await this.listExternalStorageRaw(initOverrides);
        return await response.value();
    }

    /**
     * Gets an import 
     * Get import
     */
    async listImportsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListImportsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/imports`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets an import 
     * Get import
     */
    async listImports(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListImportsResponse> {
        const response = await this.listImportsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Lists all available permissions 
     * List permissions
     */
    async listPermissionsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListPermissionsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/permissions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Lists all available permissions 
     * List permissions
     */
    async listPermissions(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListPermissionsResponse> {
        const response = await this.listPermissionsRaw(initOverrides);
        return await response.value();
    }

    /**
     * List details of all push providers. 
     * List push providers
     */
    async listPushProvidersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListPushProvidersResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/push_providers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * List details of all push providers. 
     * List push providers
     */
    async listPushProviders(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListPushProvidersResponse> {
        const response = await this.listPushProvidersRaw(initOverrides);
        return await response.value();
    }

    /**
     * Lists all available roles 
     * List roles
     */
    async listRolesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListRolesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/roles`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Lists all available roles 
     * List roles
     */
    async listRoles(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListRolesResponse> {
        const response = await this.listRolesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel 
     * Mark channels as read
     */
    async markChannelsReadRaw(requestParameters: MarkChannelsReadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MarkReadResponse>> {
        if (requestParameters.markChannelsReadRequest === null || requestParameters.markChannelsReadRequest === undefined) {
            throw new runtime.RequiredError('markChannelsReadRequest','Required parameter requestParameters.markChannelsReadRequest was null or undefined when calling markChannelsRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/read`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.markChannelsReadRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel 
     * Mark channels as read
     */
    async markChannelsRead(requestParameters: MarkChannelsReadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MarkReadResponse> {
        const response = await this.markChannelsReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel 
     * Mark read
     */
    async markReadRaw(requestParameters: MarkReadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MarkReadResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling markRead.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling markRead.');
        }

        if (requestParameters.markReadRequest === null || requestParameters.markReadRequest === undefined) {
            throw new runtime.RequiredError('markReadRequest','Required parameter requestParameters.markReadRequest was null or undefined when calling markRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/read`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.markReadRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel 
     * Mark read
     */
    async markRead(requestParameters: MarkReadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MarkReadResponse> {
        const response = await this.markReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Marks channel as unread from a specific message  Required permissions: - ReadChannel 
     * Mark unread
     */
    async markUnreadRaw(requestParameters: MarkUnreadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling markUnread.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling markUnread.');
        }

        if (requestParameters.markUnreadRequest === null || requestParameters.markUnreadRequest === undefined) {
            throw new runtime.RequiredError('markUnreadRequest','Required parameter requestParameters.markUnreadRequest was null or undefined when calling markUnread.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/unread`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.markUnreadRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Marks channel as unread from a specific message  Required permissions: - ReadChannel 
     * Mark unread
     */
    async markUnread(requestParameters: MarkUnreadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.markUnreadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mutes channel for user  Sends events: - channel.muted  Required permissions: - MuteChannel 
     * Mute channel
     */
    async muteChannelRaw(requestParameters: MuteChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MuteChannelResponse>> {
        if (requestParameters.muteChannelRequest === null || requestParameters.muteChannelRequest === undefined) {
            throw new runtime.RequiredError('muteChannelRequest','Required parameter requestParameters.muteChannelRequest was null or undefined when calling muteChannel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/moderation/mute/channel`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.muteChannelRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Mutes channel for user  Sends events: - channel.muted  Required permissions: - MuteChannel 
     * Mute channel
     */
    async muteChannel(requestParameters: MuteChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MuteChannelResponse> {
        const response = await this.muteChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mutes one or several users  Sends events: - user.muted  Required permissions: - MuteUser 
     * Mute user
     */
    async muteUserRaw(requestParameters: MuteUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MuteUserResponse>> {
        if (requestParameters.muteUserRequest === null || requestParameters.muteUserRequest === undefined) {
            throw new runtime.RequiredError('muteUserRequest','Required parameter requestParameters.muteUserRequest was null or undefined when calling muteUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/moderation/mute`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.muteUserRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Mutes one or several users  Sends events: - user.muted  Required permissions: - MuteUser 
     * Mute user
     */
    async muteUser(requestParameters: MuteUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MuteUserResponse> {
        const response = await this.muteUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find and filter channel scoped or global user bans  Required permissions: - ReadChannel 
     * Query Banned Users
     */
    async queryBannedUsersRaw(requestParameters: QueryBannedUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryBannedUsersResponse>> {
        const queryParameters: any = {};

        if (requestParameters.payload !== undefined) {
            queryParameters['payload'] = requestParameters.payload;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/query_banned_users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find and filter channel scoped or global user bans  Required permissions: - ReadChannel 
     * Query Banned Users
     */
    async queryBannedUsers(requestParameters: QueryBannedUsersOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryBannedUsersResponse> {
        const response = await this.queryBannedUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Query channels with filter query  Required permissions: - ReadChannel 
     * Query channels
     */
    async queryChannelsRaw(requestParameters: QueryChannelsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryChannelsResponse>> {
        if (requestParameters.queryChannelsRequest === null || requestParameters.queryChannelsRequest === undefined) {
            throw new runtime.RequiredError('queryChannelsRequest','Required parameter requestParameters.queryChannelsRequest was null or undefined when calling queryChannels.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.queryChannelsRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Query channels with filter query  Required permissions: - ReadChannel 
     * Query channels
     */
    async queryChannels(requestParameters: QueryChannelsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryChannelsResponse> {
        const response = await this.queryChannelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find and filter channel members  Required permissions: - ReadChannel 
     * Query members
     */
    async queryMembersRaw(requestParameters: QueryMembersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MembersResponse>> {
        const queryParameters: any = {};

        if (requestParameters.payload !== undefined) {
            queryParameters['payload'] = requestParameters.payload;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/members`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find and filter channel members  Required permissions: - ReadChannel 
     * Query members
     */
    async queryMembers(requestParameters: QueryMembersOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MembersResponse> {
        const response = await this.queryMembersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find and filter message flags  Required permissions: - ReadMessageFlags 
     * Query Message Flags
     */
    async queryMessageFlagsRaw(requestParameters: QueryMessageFlagsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryMessageFlagsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.payload !== undefined) {
            queryParameters['payload'] = requestParameters.payload;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/moderation/flags/message`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find and filter message flags  Required permissions: - ReadMessageFlags 
     * Query Message Flags
     */
    async queryMessageFlags(requestParameters: QueryMessageFlagsOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryMessageFlagsResponse> {
        const response = await this.queryMessageFlagsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Queries history for one message 
     * Query message history
     */
    async queryMessageHistoryRaw(requestParameters: QueryMessageHistoryOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryMessageHistoryResponse>> {
        if (requestParameters.queryMessageHistoryRequest === null || requestParameters.queryMessageHistoryRequest === undefined) {
            throw new runtime.RequiredError('queryMessageHistoryRequest','Required parameter requestParameters.queryMessageHistoryRequest was null or undefined when calling queryMessageHistory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/history`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.queryMessageHistoryRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Queries history for one message 
     * Query message history
     */
    async queryMessageHistory(requestParameters: QueryMessageHistoryOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryMessageHistoryResponse> {
        const response = await this.queryMessageHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Queries votes 
     * Query votes
     */
    async queryPollVotesRaw(requestParameters: QueryPollVotesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PollVotesResponse>> {
        if (requestParameters.pollId === null || requestParameters.pollId === undefined) {
            throw new runtime.RequiredError('pollId','Required parameter requestParameters.pollId was null or undefined when calling queryPollVotes.');
        }

        if (requestParameters.queryPollVotesRequest === null || requestParameters.queryPollVotesRequest === undefined) {
            throw new runtime.RequiredError('queryPollVotesRequest','Required parameter requestParameters.queryPollVotesRequest was null or undefined when calling queryPollVotes.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/polls/{poll_id}/votes`.replace(`{${"poll_id"}}`, encodeURIComponent(String(requestParameters.pollId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.queryPollVotesRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Queries votes 
     * Query votes
     */
    async queryPollVotes(requestParameters: QueryPollVotesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PollVotesResponse> {
        const response = await this.queryPollVotesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Queries polls 
     * Query polls
     */
    async queryPollsRaw(requestParameters: QueryPollsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryPollsResponse>> {
        if (requestParameters.queryPollsRequest === null || requestParameters.queryPollsRequest === undefined) {
            throw new runtime.RequiredError('queryPollsRequest','Required parameter requestParameters.queryPollsRequest was null or undefined when calling queryPolls.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/polls/query`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.queryPollsRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Queries polls 
     * Query polls
     */
    async queryPolls(requestParameters: QueryPollsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryPollsResponse> {
        const response = await this.queryPollsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get reactions on a message  Required permissions: - ReadChannel 
     */
    async queryReactionsRaw(requestParameters: QueryReactionsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryReactionsResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling queryReactions.');
        }

        if (requestParameters.queryReactionsRequest === null || requestParameters.queryReactionsRequest === undefined) {
            throw new runtime.RequiredError('queryReactionsRequest','Required parameter requestParameters.queryReactionsRequest was null or undefined when calling queryReactions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}/reactions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.queryReactionsRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get reactions on a message  Required permissions: - ReadChannel 
     */
    async queryReactions(requestParameters: QueryReactionsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryReactionsResponse> {
        const response = await this.queryReactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the list of threads for specific user  Required permissions: - ReadChannel 
     * Query Threads
     */
    async queryThreadsRaw(requestParameters: QueryThreadsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryThreadsResponse>> {
        if (requestParameters.queryThreadsRequest === null || requestParameters.queryThreadsRequest === undefined) {
            throw new runtime.RequiredError('queryThreadsRequest','Required parameter requestParameters.queryThreadsRequest was null or undefined when calling queryThreads.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/threads`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.queryThreadsRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the list of threads for specific user  Required permissions: - ReadChannel 
     * Query Threads
     */
    async queryThreads(requestParameters: QueryThreadsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryThreadsResponse> {
        const response = await this.queryThreadsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find and filter users  Required permissions: - SearchUser 
     * Query users
     */
    async queryUsersRaw(requestParameters: QueryUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryUsersResponse>> {
        const queryParameters: any = {};

        if (requestParameters.payload !== undefined) {
            queryParameters['payload'] = requestParameters.payload;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find and filter users  Required permissions: - SearchUser 
     * Query users
     */
    async queryUsers(requestParameters: QueryUsersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryUsersResponse> {
        const response = await this.queryUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Activates user who\'s been deactivated previously  Sends events: - user.reactivated 
     * Reactivate user
     */
    async reactivateUserRaw(requestParameters: ReactivateUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReactivateUserResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling reactivateUser.');
        }

        if (requestParameters.reactivateUserRequest === null || requestParameters.reactivateUserRequest === undefined) {
            throw new runtime.RequiredError('reactivateUserRequest','Required parameter requestParameters.reactivateUserRequest was null or undefined when calling reactivateUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users/{user_id}/reactivate`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.reactivateUserRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Activates user who\'s been deactivated previously  Sends events: - user.reactivated 
     * Reactivate user
     */
    async reactivateUser(requestParameters: ReactivateUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReactivateUserResponse> {
        const response = await this.reactivateUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reactivate users in batches  Sends events: - user.reactivated 
     * Reactivate users
     */
    async reactivateUsersRaw(requestParameters: ReactivateUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReactivateUsersResponse>> {
        if (requestParameters.reactivateUsersRequest === null || requestParameters.reactivateUsersRequest === undefined) {
            throw new runtime.RequiredError('reactivateUsersRequest','Required parameter requestParameters.reactivateUsersRequest was null or undefined when calling reactivateUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users/reactivate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.reactivateUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Reactivate users in batches  Sends events: - user.reactivated 
     * Reactivate users
     */
    async reactivateUsers(requestParameters: ReactivateUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReactivateUsersResponse> {
        const response = await this.reactivateUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a vote from a poll  Sends events: - poll.vote_removed  Required permissions: - CastVote 
     * Delete vote
     */
    async removePollVoteRaw(requestParameters: RemovePollVoteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PollVoteResponse>> {
        if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
            throw new runtime.RequiredError('messageId','Required parameter requestParameters.messageId was null or undefined when calling removePollVote.');
        }

        if (requestParameters.pollId === null || requestParameters.pollId === undefined) {
            throw new runtime.RequiredError('pollId','Required parameter requestParameters.pollId was null or undefined when calling removePollVote.');
        }

        if (requestParameters.voteId === null || requestParameters.voteId === undefined) {
            throw new runtime.RequiredError('voteId','Required parameter requestParameters.voteId was null or undefined when calling removePollVote.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{message_id}/polls/{poll_id}/vote/{vote_id}`.replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters.messageId))).replace(`{${"poll_id"}}`, encodeURIComponent(String(requestParameters.pollId))).replace(`{${"vote_id"}}`, encodeURIComponent(String(requestParameters.voteId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Delete a vote from a poll  Sends events: - poll.vote_removed  Required permissions: - CastVote 
     * Delete vote
     */
    async removePollVote(requestParameters: RemovePollVoteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PollVoteResponse> {
        const response = await this.removePollVoteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Restore soft deleted users 
     * Restore users
     */
    async restoreUsersRaw(requestParameters: RestoreUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.restoreUsersRequest === null || requestParameters.restoreUsersRequest === undefined) {
            throw new runtime.RequiredError('restoreUsersRequest','Required parameter requestParameters.restoreUsersRequest was null or undefined when calling restoreUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users/restore`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restoreUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Restore soft deleted users 
     * Restore users
     */
    async restoreUsers(requestParameters: RestoreUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.restoreUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Executes message command action with given parameters  Sends events: - message.new  Required permissions: - RunMessageAction 
     * Run message command action
     */
    async runMessageActionRaw(requestParameters: RunMessageActionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling runMessageAction.');
        }

        if (requestParameters.messageActionRequest === null || requestParameters.messageActionRequest === undefined) {
            throw new runtime.RequiredError('messageActionRequest','Required parameter requestParameters.messageActionRequest was null or undefined when calling runMessageAction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}/action`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.messageActionRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Executes message command action with given parameters  Sends events: - message.new  Required permissions: - RunMessageAction 
     * Run message command action
     */
    async runMessageAction(requestParameters: RunMessageActionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageResponse> {
        const response = await this.runMessageActionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search messages across channels  Required permissions: - ReadChannel 
     * Search messages
     */
    async searchRaw(requestParameters: SearchOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchResponse>> {
        const queryParameters: any = {};

        if (requestParameters.payload !== undefined) {
            queryParameters['payload'] = requestParameters.payload;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Search messages across channels  Required permissions: - ReadChannel 
     * Search messages
     */
    async search(requestParameters: SearchOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchResponse> {
        const response = await this.searchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sends event to the channel  Required permissions: - SendCustomEvent 
     * Send event
     */
    async sendEventRaw(requestParameters: SendEventOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EventResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling sendEvent.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sendEvent.');
        }

        if (requestParameters.sendEventRequest === null || requestParameters.sendEventRequest === undefined) {
            throw new runtime.RequiredError('sendEventRequest','Required parameter requestParameters.sendEventRequest was null or undefined when calling sendEvent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/event`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.sendEventRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sends event to the channel  Required permissions: - SendCustomEvent 
     * Send event
     */
    async sendEvent(requestParameters: SendEventOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EventResponse> {
        const response = await this.sendEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sends new message to the specified channel  Sends events: - message.new - message.updated  Required permissions: - AddLinks - CreateMessage - PinMessage - SkipChannelCooldown - SkipMessageModeration - UseFrozenChannel 
     * Send new message
     */
    async sendMessageRaw(requestParameters: SendMessageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SendMessageResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling sendMessage.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sendMessage.');
        }

        if (requestParameters.sendMessageRequest === null || requestParameters.sendMessageRequest === undefined) {
            throw new runtime.RequiredError('sendMessageRequest','Required parameter requestParameters.sendMessageRequest was null or undefined when calling sendMessage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/message`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.sendMessageRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sends new message to the specified channel  Sends events: - message.new - message.updated  Required permissions: - AddLinks - CreateMessage - PinMessage - SkipChannelCooldown - SkipMessageModeration - UseFrozenChannel 
     * Send new message
     */
    async sendMessage(requestParameters: SendMessageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SendMessageResponse> {
        const response = await this.sendMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sends reaction to specified message  Sends events: - reaction.new - reaction.updated  Required permissions: - CreateReaction - UseFrozenChannel 
     * Send reaction
     */
    async sendReactionRaw(requestParameters: SendReactionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SendReactionResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sendReaction.');
        }

        if (requestParameters.sendReactionRequest === null || requestParameters.sendReactionRequest === undefined) {
            throw new runtime.RequiredError('sendReactionRequest','Required parameter requestParameters.sendReactionRequest was null or undefined when calling sendReaction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}/reaction`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.sendReactionRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sends reaction to specified message  Sends events: - reaction.new - reaction.updated  Required permissions: - CreateReaction - UseFrozenChannel 
     * Send reaction
     */
    async sendReaction(requestParameters: SendReactionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SendReactionResponse> {
        const response = await this.sendReactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sends a custom event to a user  Sends events: - * 
     * Send user event
     */
    async sendUserCustomEventRaw(requestParameters: SendUserCustomEventOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling sendUserCustomEvent.');
        }

        if (requestParameters.sendUserCustomEventRequest === null || requestParameters.sendUserCustomEventRequest === undefined) {
            throw new runtime.RequiredError('sendUserCustomEventRequest','Required parameter requestParameters.sendUserCustomEventRequest was null or undefined when calling sendUserCustomEvent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users/{user_id}/event`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.sendUserCustomEventRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sends a custom event to a user  Sends events: - * 
     * Send user event
     */
    async sendUserCustomEvent(requestParameters: SendUserCustomEventOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.sendUserCustomEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Shows previously hidden channel  Sends events: - channel.visible 
     * Show channel
     */
    async showChannelRaw(requestParameters: ShowChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShowChannelResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling showChannel.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling showChannel.');
        }

        if (requestParameters.showChannelRequest === null || requestParameters.showChannelRequest === undefined) {
            throw new runtime.RequiredError('showChannelRequest','Required parameter requestParameters.showChannelRequest was null or undefined when calling showChannel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/show`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.showChannelRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Shows previously hidden channel  Sends events: - channel.visible 
     * Show channel
     */
    async showChannel(requestParameters: ShowChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShowChannelResponse> {
        const response = await this.showChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Translates message to a given language using automated translation software  Sends events: - message.updated  Required permissions: - ReadChannel 
     * Translate message
     */
    async translateMessageRaw(requestParameters: TranslateMessageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling translateMessage.');
        }

        if (requestParameters.translateMessageRequest === null || requestParameters.translateMessageRequest === undefined) {
            throw new runtime.RequiredError('translateMessageRequest','Required parameter requestParameters.translateMessageRequest was null or undefined when calling translateMessage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}/translate`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.translateMessageRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Translates message to a given language using automated translation software  Sends events: - message.updated  Required permissions: - ReadChannel 
     * Translate message
     */
    async translateMessage(requestParameters: TranslateMessageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageResponse> {
        const response = await this.translateMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Truncates channel  Sends events: - channel.truncated  Required permissions: - DeleteChannel - TruncateChannel 
     * Truncate channel
     */
    async truncateChannelRaw(requestParameters: TruncateChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TruncateChannelResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling truncateChannel.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling truncateChannel.');
        }

        if (requestParameters.truncateChannelRequest === null || requestParameters.truncateChannelRequest === undefined) {
            throw new runtime.RequiredError('truncateChannelRequest','Required parameter requestParameters.truncateChannelRequest was null or undefined when calling truncateChannel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/truncate`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.truncateChannelRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Truncates channel  Sends events: - channel.truncated  Required permissions: - DeleteChannel - TruncateChannel 
     * Truncate channel
     */
    async truncateChannel(requestParameters: TruncateChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TruncateChannelResponse> {
        const response = await this.truncateChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Removes previously applied ban  Sends events: - user.unbanned  Required permissions: - BanChannelMember - BanUser 
     * Unban user
     */
    async unbanRaw(requestParameters: UnbanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.targetUserId === null || requestParameters.targetUserId === undefined) {
            throw new runtime.RequiredError('targetUserId','Required parameter requestParameters.targetUserId was null or undefined when calling unban.');
        }

        const queryParameters: any = {};

        if (requestParameters.targetUserId !== undefined) {
            queryParameters['target_user_id'] = requestParameters.targetUserId;
        }

        if (requestParameters.channelCid !== undefined) {
            queryParameters['channel_cid'] = requestParameters.channelCid;
        }

        if (requestParameters.createdBy !== undefined) {
            queryParameters['created_by'] = requestParameters.createdBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/moderation/ban`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Removes previously applied ban  Sends events: - user.unbanned  Required permissions: - BanChannelMember - BanUser 
     * Unban user
     */
    async unban(requestParameters: UnbanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.unbanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unblock users 
     * Unblock user
     */
    async unblockUsersRaw(requestParameters: UnblockUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UnblockUsersResponse>> {
        if (requestParameters.unblockUsersRequest === null || requestParameters.unblockUsersRequest === undefined) {
            throw new runtime.RequiredError('unblockUsersRequest','Required parameter requestParameters.unblockUsersRequest was null or undefined when calling unblockUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users/unblock`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.unblockUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Unblock users 
     * Unblock user
     */
    async unblockUsers(requestParameters: UnblockUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UnblockUsersResponse> {
        const response = await this.unblockUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Undelete a message that was previously soft-deleted  Sends events: - message.undeleted 
     * Undelete message
     */
    async undeleteMessageRaw(requestParameters: UndeleteMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateMessageResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling undeleteMessage.');
        }

        if (requestParameters.updateMessageRequest === null || requestParameters.updateMessageRequest === undefined) {
            throw new runtime.RequiredError('updateMessageRequest','Required parameter requestParameters.updateMessageRequest was null or undefined when calling undeleteMessage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}/undelete`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateMessageRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Undelete a message that was previously soft-deleted  Sends events: - message.undeleted 
     * Undelete message
     */
    async undeleteMessage(requestParameters: UndeleteMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateMessageResponse> {
        const response = await this.undeleteMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unmutes channel for user  Sends events: - channel.unmuted  Required permissions: - MuteChannel 
     * Unmute channel
     */
    async unmuteChannelRaw(requestParameters: UnmuteChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UnmuteResponse>> {
        if (requestParameters.unmuteChannelRequest === null || requestParameters.unmuteChannelRequest === undefined) {
            throw new runtime.RequiredError('unmuteChannelRequest','Required parameter requestParameters.unmuteChannelRequest was null or undefined when calling unmuteChannel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/moderation/unmute/channel`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.unmuteChannelRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Unmutes channel for user  Sends events: - channel.unmuted  Required permissions: - MuteChannel 
     * Unmute channel
     */
    async unmuteChannel(requestParameters: UnmuteChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UnmuteResponse> {
        const response = await this.unmuteChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unmutes previously muted user  Sends events: - user.unmuted  Required permissions: - MuteUser 
     * Unmute user
     */
    async unmuteUserRaw(requestParameters: UnmuteUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UnmuteResponse>> {
        if (requestParameters.unmuteUserRequest === null || requestParameters.unmuteUserRequest === undefined) {
            throw new runtime.RequiredError('unmuteUserRequest','Required parameter requestParameters.unmuteUserRequest was null or undefined when calling unmuteUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/moderation/unmute`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.unmuteUserRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Unmutes previously muted user  Sends events: - user.unmuted  Required permissions: - MuteUser 
     * Unmute user
     */
    async unmuteUser(requestParameters: UnmuteUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UnmuteResponse> {
        const response = await this.unmuteUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch unread counts for a single user 
     * Unread counts
     */
    async unreadCountsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WrappedUnreadCountsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/unread`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Fetch unread counts for a single user 
     * Unread counts
     */
    async unreadCounts(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WrappedUnreadCountsResponse> {
        const response = await this.unreadCountsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Fetch unread counts in batch for multiple users in one call 
     * Batch unread counts
     */
    async unreadCountsBatchRaw(requestParameters: UnreadCountsBatchOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UnreadCountsBatchResponse>> {
        if (requestParameters.unreadCountsBatchRequest === null || requestParameters.unreadCountsBatchRequest === undefined) {
            throw new runtime.RequiredError('unreadCountsBatchRequest','Required parameter requestParameters.unreadCountsBatchRequest was null or undefined when calling unreadCountsBatch.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/unread_batch`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.unreadCountsBatchRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Fetch unread counts in batch for multiple users in one call 
     * Batch unread counts
     */
    async unreadCountsBatch(requestParameters: UnreadCountsBatchOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UnreadCountsBatchResponse> {
        const response = await this.unreadCountsBatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This Method updates one or more application settings 
     * Update App Settings
     */
    async updateAppRaw(requestParameters: UpdateAppOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.updateAppRequest === null || requestParameters.updateAppRequest === undefined) {
            throw new runtime.RequiredError('updateAppRequest','Required parameter requestParameters.updateAppRequest was null or undefined when calling updateApp.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/app`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateAppRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * This Method updates one or more application settings 
     * Update App Settings
     */
    async updateApp(requestParameters: UpdateAppOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.updateAppRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates contents of the block list 
     * Update block list
     */
    async updateBlockListRaw(requestParameters: UpdateBlockListOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling updateBlockList.');
        }

        if (requestParameters.updateBlockListRequest === null || requestParameters.updateBlockListRequest === undefined) {
            throw new runtime.RequiredError('updateBlockListRequest','Required parameter requestParameters.updateBlockListRequest was null or undefined when calling updateBlockList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/blocklists/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateBlockListRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates contents of the block list 
     * Update block list
     */
    async updateBlockList(requestParameters: UpdateBlockListOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.updateBlockListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Change channel data  Sends events: - channel.updated - member.added - member.removed - member.updated - message.new  Required permissions: - AddOwnChannelMembership - RemoveOwnChannelMembership - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen - UpdateChannelMembers 
     * Update channel
     */
    async updateChannelRaw(requestParameters: UpdateChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateChannelResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling updateChannel.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateChannel.');
        }

        if (requestParameters.updateChannelRequest === null || requestParameters.updateChannelRequest === undefined) {
            throw new runtime.RequiredError('updateChannelRequest','Required parameter requestParameters.updateChannelRequest was null or undefined when calling updateChannel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateChannelRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Change channel data  Sends events: - channel.updated - member.added - member.removed - member.updated - message.new  Required permissions: - AddOwnChannelMembership - RemoveOwnChannelMembership - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen - UpdateChannelMembers 
     * Update channel
     */
    async updateChannel(requestParameters: UpdateChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateChannelResponse> {
        const response = await this.updateChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates certain fields of the channel  Sends events: - channel.updated  Required permissions: - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen 
     * Partially update channel
     */
    async updateChannelPartialRaw(requestParameters: UpdateChannelPartialOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateChannelPartialResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling updateChannelPartial.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateChannelPartial.');
        }

        if (requestParameters.updateChannelPartialRequest === null || requestParameters.updateChannelPartialRequest === undefined) {
            throw new runtime.RequiredError('updateChannelPartialRequest','Required parameter requestParameters.updateChannelPartialRequest was null or undefined when calling updateChannelPartial.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateChannelPartialRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates certain fields of the channel  Sends events: - channel.updated  Required permissions: - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen 
     * Partially update channel
     */
    async updateChannelPartial(requestParameters: UpdateChannelPartialOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateChannelPartialResponse> {
        const response = await this.updateChannelPartialRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates channel type 
     * Update channel type
     */
    async updateChannelTypeRaw(requestParameters: UpdateChannelTypeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateChannelTypeResponse>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling updateChannelType.');
        }

        if (requestParameters.updateChannelTypeRequest === null || requestParameters.updateChannelTypeRequest === undefined) {
            throw new runtime.RequiredError('updateChannelTypeRequest','Required parameter requestParameters.updateChannelTypeRequest was null or undefined when calling updateChannelType.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channeltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateChannelTypeRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates channel type 
     * Update channel type
     */
    async updateChannelType(requestParameters: UpdateChannelTypeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateChannelTypeResponse> {
        const response = await this.updateChannelTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates custom chat command 
     * Update command
     */
    async updateCommandRaw(requestParameters: UpdateCommandOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateCommandResponse>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling updateCommand.');
        }

        if (requestParameters.updateCommandRequest === null || requestParameters.updateCommandRequest === undefined) {
            throw new runtime.RequiredError('updateCommandRequest','Required parameter requestParameters.updateCommandRequest was null or undefined when calling updateCommand.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/commands/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateCommandRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates custom chat command 
     * Update command
     */
    async updateCommand(requestParameters: UpdateCommandOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateCommandResponse> {
        const response = await this.updateCommandRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  
     * Update External Storage
     */
    async updateExternalStorageRaw(requestParameters: UpdateExternalStorageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateExternalStorageResponse>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling updateExternalStorage.');
        }

        if (requestParameters.updateExternalStorageRequest === null || requestParameters.updateExternalStorageRequest === undefined) {
            throw new runtime.RequiredError('updateExternalStorageRequest','Required parameter requestParameters.updateExternalStorageRequest was null or undefined when calling updateExternalStorage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/external_storage/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateExternalStorageRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *  
     * Update External Storage
     */
    async updateExternalStorage(requestParameters: UpdateExternalStorageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateExternalStorageResponse> {
        const response = await this.updateExternalStorageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates message with new data  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage 
     * Update message
     */
    async updateMessageRaw(requestParameters: UpdateMessageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateMessageResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateMessage.');
        }

        if (requestParameters.updateMessageRequest === null || requestParameters.updateMessageRequest === undefined) {
            throw new runtime.RequiredError('updateMessageRequest','Required parameter requestParameters.updateMessageRequest was null or undefined when calling updateMessage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateMessageRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates message with new data  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage 
     * Update message
     */
    async updateMessage(requestParameters: UpdateMessageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateMessageResponse> {
        const response = await this.updateMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates certain fields of the message  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage 
     * Partially message update
     */
    async updateMessagePartialRaw(requestParameters: UpdateMessagePartialOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateMessagePartialResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateMessagePartial.');
        }

        if (requestParameters.updateMessagePartialRequest === null || requestParameters.updateMessagePartialRequest === undefined) {
            throw new runtime.RequiredError('updateMessagePartialRequest','Required parameter requestParameters.updateMessagePartialRequest was null or undefined when calling updateMessagePartial.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateMessagePartialRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates certain fields of the message  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage 
     * Partially message update
     */
    async updateMessagePartial(requestParameters: UpdateMessagePartialOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateMessagePartialResponse> {
        const response = await this.updateMessagePartialRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a poll  Sends events: - poll.closed - poll.updated  Required permissions: - UpdatePoll 
     * Update poll
     */
    async updatePollRaw(requestParameters: UpdatePollOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PollResponse>> {
        if (requestParameters.updatePollRequest === null || requestParameters.updatePollRequest === undefined) {
            throw new runtime.RequiredError('updatePollRequest','Required parameter requestParameters.updatePollRequest was null or undefined when calling updatePoll.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/polls`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updatePollRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates a poll  Sends events: - poll.closed - poll.updated  Required permissions: - UpdatePoll 
     * Update poll
     */
    async updatePoll(requestParameters: UpdatePollOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PollResponse> {
        const response = await this.updatePollRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a poll option  Sends events: - poll.updated  Required permissions: - UpdatePoll 
     * Update poll option
     */
    async updatePollOptionRaw(requestParameters: UpdatePollOptionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PollOptionResponse>> {
        if (requestParameters.pollId === null || requestParameters.pollId === undefined) {
            throw new runtime.RequiredError('pollId','Required parameter requestParameters.pollId was null or undefined when calling updatePollOption.');
        }

        if (requestParameters.updatePollOptionRequest === null || requestParameters.updatePollOptionRequest === undefined) {
            throw new runtime.RequiredError('updatePollOptionRequest','Required parameter requestParameters.updatePollOptionRequest was null or undefined when calling updatePollOption.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/polls/{poll_id}/options`.replace(`{${"poll_id"}}`, encodeURIComponent(String(requestParameters.pollId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updatePollOptionRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates a poll option  Sends events: - poll.updated  Required permissions: - UpdatePoll 
     * Update poll option
     */
    async updatePollOption(requestParameters: UpdatePollOptionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PollOptionResponse> {
        const response = await this.updatePollOptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a poll partially  Sends events: - poll.updated  Required permissions: - UpdatePoll 
     * Partial update poll
     */
    async updatePollPartialRaw(requestParameters: UpdatePollPartialOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PollResponse>> {
        if (requestParameters.pollId === null || requestParameters.pollId === undefined) {
            throw new runtime.RequiredError('pollId','Required parameter requestParameters.pollId was null or undefined when calling updatePollPartial.');
        }

        if (requestParameters.updatePollPartialRequest === null || requestParameters.updatePollPartialRequest === undefined) {
            throw new runtime.RequiredError('updatePollPartialRequest','Required parameter requestParameters.updatePollPartialRequest was null or undefined when calling updatePollPartial.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/polls/{poll_id}`.replace(`{${"poll_id"}}`, encodeURIComponent(String(requestParameters.pollId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updatePollPartialRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates a poll partially  Sends events: - poll.updated  Required permissions: - UpdatePoll 
     * Partial update poll
     */
    async updatePollPartial(requestParameters: UpdatePollPartialOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PollResponse> {
        const response = await this.updatePollPartialRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates certain fields of the thread  Sends events: - thread.updated  Required permissions: - ReadChannel - UpdateThread 
     * Partially update thread
     */
    async updateThreadPartialRaw(requestParameters: UpdateThreadPartialOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateThreadPartialResponse>> {
        if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
            throw new runtime.RequiredError('messageId','Required parameter requestParameters.messageId was null or undefined when calling updateThreadPartial.');
        }

        if (requestParameters.updateThreadPartialRequest === null || requestParameters.updateThreadPartialRequest === undefined) {
            throw new runtime.RequiredError('updateThreadPartialRequest','Required parameter requestParameters.updateThreadPartialRequest was null or undefined when calling updateThreadPartial.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/threads/{message_id}`.replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters.messageId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateThreadPartialRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates certain fields of the thread  Sends events: - thread.updated  Required permissions: - ReadChannel - UpdateThread 
     * Partially update thread
     */
    async updateThreadPartial(requestParameters: UpdateThreadPartialOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateThreadPartialResponse> {
        const response = await this.updateThreadPartialRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update or create users in bulk  Sends events: - user.updated 
     * Upsert users
     */
    async updateUsersRaw(requestParameters: UpdateUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateUsersResponse>> {
        if (requestParameters.updateUsersRequest === null || requestParameters.updateUsersRequest === undefined) {
            throw new runtime.RequiredError('updateUsersRequest','Required parameter requestParameters.updateUsersRequest was null or undefined when calling updateUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update or create users in bulk  Sends events: - user.updated 
     * Upsert users
     */
    async updateUsers(requestParameters: UpdateUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateUsersResponse> {
        const response = await this.updateUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates certain fields of the user  Sends events: - user.presence.changed - user.updated 
     * Partially update user
     */
    async updateUsersPartialRaw(requestParameters: UpdateUsersPartialOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateUsersResponse>> {
        if (requestParameters.updateUsersPartialRequest === null || requestParameters.updateUsersPartialRequest === undefined) {
            throw new runtime.RequiredError('updateUsersPartialRequest','Required parameter requestParameters.updateUsersPartialRequest was null or undefined when calling updateUsersPartial.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateUsersPartialRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates certain fields of the user  Sends events: - user.presence.changed - user.updated 
     * Partially update user
     */
    async updateUsersPartial(requestParameters: UpdateUsersPartialOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateUsersResponse> {
        const response = await this.updateUsersPartialRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Uploads file  Required permissions: - UploadAttachment 
     * Upload file
     */
    async uploadFileRaw(requestParameters: UploadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FileUploadResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling uploadFile.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling uploadFile.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        if (requestParameters.user !== undefined) {

            formParams.append('user', new Blob([JSON.stringify(requestParameters.user)], { type: "application/json", }));
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/file`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Uploads file  Required permissions: - UploadAttachment 
     * Upload file
     */
    async uploadFile(requestParameters: UploadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FileUploadResponse> {
        const response = await this.uploadFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Uploads image  Required permissions: - UploadAttachment 
     * Upload image
     */
    async uploadImageRaw(requestParameters: UploadImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImageUploadResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling uploadImage.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling uploadImage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        if (requestParameters.uploadSizes) {
            formParams.append('upload_sizes', requestParameters.uploadSizes.join(runtime.COLLECTION_FORMATS["csv"]));
        }

        if (requestParameters.user !== undefined) {

            formParams.append('user', new Blob([JSON.stringify(requestParameters.user)], { type: "application/json", }));
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/image`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Uploads image  Required permissions: - UploadAttachment 
     * Upload image
     */
    async uploadImage(requestParameters: UploadImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImageUploadResponse> {
        const response = await this.uploadImageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upsert a push provider for v2 with multi bundle/package support 
     * Upsert a push provider
     */
    async upsertPushProviderRaw(requestParameters: UpsertPushProviderOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpsertPushProviderResponse>> {
        if (requestParameters.upsertPushProviderRequest === null || requestParameters.upsertPushProviderRequest === undefined) {
            throw new runtime.RequiredError('upsertPushProviderRequest','Required parameter requestParameters.upsertPushProviderRequest was null or undefined when calling upsertPushProvider.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/push_providers`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.upsertPushProviderRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Upsert a push provider for v2 with multi bundle/package support 
     * Upsert a push provider
     */
    async upsertPushProvider(requestParameters: UpsertPushProviderOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpsertPushProviderResponse> {
        const response = await this.upsertPushProviderRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const DeletePushProviderTypeEnum = {
    APN: 'apn',
    FIREBASE: 'firebase',
    HUAWEI: 'huawei',
    XIAOMI: 'xiaomi'
} as const;
export type DeletePushProviderTypeEnum = typeof DeletePushProviderTypeEnum[keyof typeof DeletePushProviderTypeEnum];
