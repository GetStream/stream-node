/* tslint:disable */
/* eslint-disable */
/**
 * Stream Chat API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v92.7.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  APIError,
  ChannelGetOrCreateRequest,
  ChannelStateResponse,
  ChannelsResponse,
  DeleteChannelResponse,
  DeleteChannelsRequest,
  DeleteChannelsResponse,
  ExportChannelsRequest,
  ExportChannelsResponse,
  GetExportChannelsStatusResponse,
  HideChannelRequest,
  HideChannelResponse,
  MarkChannelsReadRequest,
  MarkReadRequest,
  MarkReadResponse,
  MarkUnreadRequest,
  MembersResponse,
  MuteChannelRequest,
  MuteChannelResponse,
  QueryChannelsRequest,
  QueryMembersRequest,
  Response,
  SearchRequest,
  SearchResponse,
  ShowChannelRequest,
  ShowChannelResponse,
  TruncateChannelRequest,
  TruncateChannelResponse,
  UnmuteChannelRequest,
  UnmuteResponse,
  UnreadCountsResponse,
  UpdateChannelPartialRequest,
  UpdateChannelPartialResponse,
  UpdateChannelRequest,
  UpdateChannelResponse,
} from '../models';

export interface DeleteChannelRequest {
    type: string;
    id: string;
    hardDelete?: boolean;
}

export interface DeleteChannelsOperationRequest {
    deleteChannelsRequest: DeleteChannelsRequest | null;
}

export interface ExportChannelsOperationRequest {
    exportChannelsRequest: ExportChannelsRequest | null;
}

export interface GetExportChannelsStatusRequest {
    id: string;
}

export interface GetOrCreateChannelRequest {
    type: string;
    id: string;
    channelGetOrCreateRequest: ChannelGetOrCreateRequest | null;
}

export interface HideChannelOperationRequest {
    type: string;
    id: string;
    hideChannelRequest: HideChannelRequest | null;
}

export interface MarkChannelsReadOperationRequest {
    markChannelsReadRequest: MarkChannelsReadRequest | null;
}

export interface MarkReadOperationRequest {
    type: string;
    id: string;
    markReadRequest: MarkReadRequest | null;
}

export interface MarkUnreadOperationRequest {
    type: string;
    id: string;
    markUnreadRequest: MarkUnreadRequest | null;
}

export interface MuteChannelOperationRequest {
    muteChannelRequest: MuteChannelRequest | null;
}

export interface QueryChannelsOperationRequest {
    queryChannelsRequest: QueryChannelsRequest | null;
}

export interface QueryMembersOperationRequest {
    payload?: QueryMembersRequest;
}

export interface SearchOperationRequest {
    payload?: SearchRequest;
}

export interface ShowChannelOperationRequest {
    type: string;
    id: string;
    showChannelRequest: ShowChannelRequest | null;
}

export interface TruncateChannelOperationRequest {
    type: string;
    id: string;
    truncateChannelRequest: TruncateChannelRequest | null;
}

export interface UnmuteChannelOperationRequest {
    unmuteChannelRequest: UnmuteChannelRequest | null;
}

export interface UpdateChannelOperationRequest {
    type: string;
    id: string;
    updateChannelRequest: UpdateChannelRequest | null;
}

export interface UpdateChannelPartialOperationRequest {
    type: string;
    id: string;
    updateChannelPartialRequest: UpdateChannelPartialRequest | null;
}

/**
 * 
 */
export class ChannelsApi extends runtime.BaseAPI {

    /**
     * Deletes channel  Sends events: - channel.deleted  Required permissions: - DeleteChannel 
     * Delete channel
     */
    async deleteChannelRaw(requestParameters: DeleteChannelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteChannelResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling deleteChannel.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteChannel.');
        }

        const queryParameters: any = {};

        if (requestParameters.hardDelete !== undefined) {
            queryParameters['hard_delete'] = requestParameters.hardDelete;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes channel  Sends events: - channel.deleted  Required permissions: - DeleteChannel 
     * Delete channel
     */
    async deleteChannel(requestParameters: DeleteChannelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteChannelResponse> {
        const response = await this.deleteChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Allows to delete several channels at once asynchronously  Sends events: - channel.deleted  Required permissions: - DeleteChannel 
     * Deletes channels asynchronously
     */
    async deleteChannelsRaw(requestParameters: DeleteChannelsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteChannelsResponse>> {
        if (requestParameters.deleteChannelsRequest === null || requestParameters.deleteChannelsRequest === undefined) {
            throw new runtime.RequiredError('deleteChannelsRequest','Required parameter requestParameters.deleteChannelsRequest was null or undefined when calling deleteChannels.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/delete`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.deleteChannelsRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Allows to delete several channels at once asynchronously  Sends events: - channel.deleted  Required permissions: - DeleteChannel 
     * Deletes channels asynchronously
     */
    async deleteChannels(requestParameters: DeleteChannelsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteChannelsResponse> {
        const response = await this.deleteChannelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Exports channel data to JSON file 
     * Export channels
     */
    async exportChannelsRaw(requestParameters: ExportChannelsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportChannelsResponse>> {
        if (requestParameters.exportChannelsRequest === null || requestParameters.exportChannelsRequest === undefined) {
            throw new runtime.RequiredError('exportChannelsRequest','Required parameter requestParameters.exportChannelsRequest was null or undefined when calling exportChannels.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/export_channels`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.exportChannelsRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Exports channel data to JSON file 
     * Export channels
     */
    async exportChannels(requestParameters: ExportChannelsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportChannelsResponse> {
        const response = await this.exportChannelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  
     * Export channels status
     */
    async getExportChannelsStatusRaw(requestParameters: GetExportChannelsStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetExportChannelsStatusResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getExportChannelsStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/export_channels/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *  
     * Export channels status
     */
    async getExportChannelsStatus(requestParameters: GetExportChannelsStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetExportChannelsStatusResponse> {
        const response = await this.getExportChannelsStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This method creates a channel or returns an existing one with matching attributes  Sends events: - channel.created - member.added - member.removed - member.updated - user.watching.start 
     * Get or create channel
     */
    async getOrCreateChannelRaw(requestParameters: GetOrCreateChannelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChannelStateResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling getOrCreateChannel.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getOrCreateChannel.');
        }

        if (requestParameters.channelGetOrCreateRequest === null || requestParameters.channelGetOrCreateRequest === undefined) {
            throw new runtime.RequiredError('channelGetOrCreateRequest','Required parameter requestParameters.channelGetOrCreateRequest was null or undefined when calling getOrCreateChannel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/query`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.channelGetOrCreateRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * This method creates a channel or returns an existing one with matching attributes  Sends events: - channel.created - member.added - member.removed - member.updated - user.watching.start 
     * Get or create channel
     */
    async getOrCreateChannel(requestParameters: GetOrCreateChannelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChannelStateResponse> {
        const response = await this.getOrCreateChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Marks channel as hidden for current user  Sends events: - channel.hidden  Required permissions: - ReadChannel 
     * Hide channel
     */
    async hideChannelRaw(requestParameters: HideChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HideChannelResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling hideChannel.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling hideChannel.');
        }

        if (requestParameters.hideChannelRequest === null || requestParameters.hideChannelRequest === undefined) {
            throw new runtime.RequiredError('hideChannelRequest','Required parameter requestParameters.hideChannelRequest was null or undefined when calling hideChannel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/hide`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.hideChannelRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Marks channel as hidden for current user  Sends events: - channel.hidden  Required permissions: - ReadChannel 
     * Hide channel
     */
    async hideChannel(requestParameters: HideChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HideChannelResponse> {
        const response = await this.hideChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel 
     * Mark channels as read
     */
    async markChannelsReadRaw(requestParameters: MarkChannelsReadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MarkReadResponse>> {
        if (requestParameters.markChannelsReadRequest === null || requestParameters.markChannelsReadRequest === undefined) {
            throw new runtime.RequiredError('markChannelsReadRequest','Required parameter requestParameters.markChannelsReadRequest was null or undefined when calling markChannelsRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/read`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.markChannelsReadRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel 
     * Mark channels as read
     */
    async markChannelsRead(requestParameters: MarkChannelsReadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MarkReadResponse> {
        const response = await this.markChannelsReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel 
     * Mark read
     */
    async markReadRaw(requestParameters: MarkReadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MarkReadResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling markRead.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling markRead.');
        }

        if (requestParameters.markReadRequest === null || requestParameters.markReadRequest === undefined) {
            throw new runtime.RequiredError('markReadRequest','Required parameter requestParameters.markReadRequest was null or undefined when calling markRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/read`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.markReadRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel 
     * Mark read
     */
    async markRead(requestParameters: MarkReadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MarkReadResponse> {
        const response = await this.markReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Marks channel as unread from a specific message  Required permissions: - ReadChannel 
     * Mark unread
     */
    async markUnreadRaw(requestParameters: MarkUnreadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling markUnread.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling markUnread.');
        }

        if (requestParameters.markUnreadRequest === null || requestParameters.markUnreadRequest === undefined) {
            throw new runtime.RequiredError('markUnreadRequest','Required parameter requestParameters.markUnreadRequest was null or undefined when calling markUnread.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/unread`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.markUnreadRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Marks channel as unread from a specific message  Required permissions: - ReadChannel 
     * Mark unread
     */
    async markUnread(requestParameters: MarkUnreadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.markUnreadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mutes channel for user  Sends events: - channel.muted  Required permissions: - MuteChannel 
     * Mute channel
     */
    async muteChannelRaw(requestParameters: MuteChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MuteChannelResponse>> {
        if (requestParameters.muteChannelRequest === null || requestParameters.muteChannelRequest === undefined) {
            throw new runtime.RequiredError('muteChannelRequest','Required parameter requestParameters.muteChannelRequest was null or undefined when calling muteChannel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/moderation/mute/channel`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.muteChannelRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Mutes channel for user  Sends events: - channel.muted  Required permissions: - MuteChannel 
     * Mute channel
     */
    async muteChannel(requestParameters: MuteChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MuteChannelResponse> {
        const response = await this.muteChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Query channels with filter query  Required permissions: - ReadChannel 
     * Query channels
     */
    async queryChannelsRaw(requestParameters: QueryChannelsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChannelsResponse>> {
        if (requestParameters.queryChannelsRequest === null || requestParameters.queryChannelsRequest === undefined) {
            throw new runtime.RequiredError('queryChannelsRequest','Required parameter requestParameters.queryChannelsRequest was null or undefined when calling queryChannels.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.queryChannelsRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Query channels with filter query  Required permissions: - ReadChannel 
     * Query channels
     */
    async queryChannels(requestParameters: QueryChannelsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChannelsResponse> {
        const response = await this.queryChannelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find and filter channel members  Required permissions: - ReadChannel 
     * Query members
     */
    async queryMembersRaw(requestParameters: QueryMembersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MembersResponse>> {
        const queryParameters: any = {};

        if (requestParameters.payload !== undefined) {
            queryParameters['payload'] = requestParameters.payload;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/members`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find and filter channel members  Required permissions: - ReadChannel 
     * Query members
     */
    async queryMembers(requestParameters: QueryMembersOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MembersResponse> {
        const response = await this.queryMembersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search messages across channels  Required permissions: - ReadChannel 
     * Search messages
     */
    async searchRaw(requestParameters: SearchOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchResponse>> {
        const queryParameters: any = {};

        if (requestParameters.payload !== undefined) {
            queryParameters['payload'] = requestParameters.payload;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Search messages across channels  Required permissions: - ReadChannel 
     * Search messages
     */
    async search(requestParameters: SearchOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchResponse> {
        const response = await this.searchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Shows previously hidden channel  Sends events: - channel.visible 
     * Show channel
     */
    async showChannelRaw(requestParameters: ShowChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShowChannelResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling showChannel.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling showChannel.');
        }

        if (requestParameters.showChannelRequest === null || requestParameters.showChannelRequest === undefined) {
            throw new runtime.RequiredError('showChannelRequest','Required parameter requestParameters.showChannelRequest was null or undefined when calling showChannel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/show`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.showChannelRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Shows previously hidden channel  Sends events: - channel.visible 
     * Show channel
     */
    async showChannel(requestParameters: ShowChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShowChannelResponse> {
        const response = await this.showChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Truncates channel  Sends events: - channel.truncated  Required permissions: - DeleteChannel - TruncateChannel 
     * Truncate channel
     */
    async truncateChannelRaw(requestParameters: TruncateChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TruncateChannelResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling truncateChannel.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling truncateChannel.');
        }

        if (requestParameters.truncateChannelRequest === null || requestParameters.truncateChannelRequest === undefined) {
            throw new runtime.RequiredError('truncateChannelRequest','Required parameter requestParameters.truncateChannelRequest was null or undefined when calling truncateChannel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/truncate`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.truncateChannelRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Truncates channel  Sends events: - channel.truncated  Required permissions: - DeleteChannel - TruncateChannel 
     * Truncate channel
     */
    async truncateChannel(requestParameters: TruncateChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TruncateChannelResponse> {
        const response = await this.truncateChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unmutes channel for user  Sends events: - channel.unmuted  Required permissions: - MuteChannel 
     * Unmute channel
     */
    async unmuteChannelRaw(requestParameters: UnmuteChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UnmuteResponse>> {
        if (requestParameters.unmuteChannelRequest === null || requestParameters.unmuteChannelRequest === undefined) {
            throw new runtime.RequiredError('unmuteChannelRequest','Required parameter requestParameters.unmuteChannelRequest was null or undefined when calling unmuteChannel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/moderation/unmute/channel`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.unmuteChannelRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Unmutes channel for user  Sends events: - channel.unmuted  Required permissions: - MuteChannel 
     * Unmute channel
     */
    async unmuteChannel(requestParameters: UnmuteChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UnmuteResponse> {
        const response = await this.unmuteChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * UnreadCount counts 
     * UnreadCount counts
     */
    async unreadCountsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UnreadCountsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/unread`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * UnreadCount counts 
     * UnreadCount counts
     */
    async unreadCounts(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UnreadCountsResponse> {
        const response = await this.unreadCountsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Change channel data  Sends events: - channel.updated - member.added - member.removed - member.updated - message.new  Required permissions: - AddOwnChannelMembership - RemoveOwnChannelMembership - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen - UpdateChannelMembers 
     * Update channel
     */
    async updateChannelRaw(requestParameters: UpdateChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateChannelResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling updateChannel.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateChannel.');
        }

        if (requestParameters.updateChannelRequest === null || requestParameters.updateChannelRequest === undefined) {
            throw new runtime.RequiredError('updateChannelRequest','Required parameter requestParameters.updateChannelRequest was null or undefined when calling updateChannel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateChannelRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Change channel data  Sends events: - channel.updated - member.added - member.removed - member.updated - message.new  Required permissions: - AddOwnChannelMembership - RemoveOwnChannelMembership - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen - UpdateChannelMembers 
     * Update channel
     */
    async updateChannel(requestParameters: UpdateChannelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateChannelResponse> {
        const response = await this.updateChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates certain fields of the channel  Sends events: - channel.updated  Required permissions: - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen 
     * Partially update channel
     */
    async updateChannelPartialRaw(requestParameters: UpdateChannelPartialOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateChannelPartialResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling updateChannelPartial.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateChannelPartial.');
        }

        if (requestParameters.updateChannelPartialRequest === null || requestParameters.updateChannelPartialRequest === undefined) {
            throw new runtime.RequiredError('updateChannelPartialRequest','Required parameter requestParameters.updateChannelPartialRequest was null or undefined when calling updateChannelPartial.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateChannelPartialRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates certain fields of the channel  Sends events: - channel.updated  Required permissions: - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen 
     * Partially update channel
     */
    async updateChannelPartial(requestParameters: UpdateChannelPartialOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateChannelPartialResponse> {
        const response = await this.updateChannelPartialRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
