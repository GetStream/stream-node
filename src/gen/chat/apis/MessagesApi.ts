/* tslint:disable */
/* eslint-disable */
/**
 * Stream Chat API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v92.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  APIError,
  FileDeleteResponse,
  FileUploadResponse,
  FlagRequest,
  FlagResponse,
  GetManyMessagesResponse,
  GetOGResponse,
  GetReactionsResponse,
  GetRepliesResponse,
  /** @ts-expect-error */
  ImageSizeRequest,
  ImageUploadResponse,
  MarkChannelsReadRequest,
  MarkReadRequest,
  MarkReadResponse,
  MarkUnreadRequest,
  MessageActionRequest,
  MessageResponse,
  MessageWithPendingMetadataResponse,
  /** @ts-expect-error */
  OnlyUserIDRequest,
  QueryMessageFlagsRequest,
  QueryMessageFlagsResponse,
  ReactionRemovalResponse,
  ReactionResponse,
  Response,
  SearchRequest,
  SearchResponse,
  SendMessageRequest,
  SendReactionRequest,
  TranslateMessageRequest,
  UpdateMessagePartialRequest,
  UpdateMessageRequest,
} from '../models';

export interface DeleteFileRequest {
    type: string;
    id: string;
    url?: string;
}

export interface DeleteImageRequest {
    type: string;
    id: string;
    url?: string;
}

export interface DeleteMessageRequest {
    id: string;
    hard?: boolean;
    deletedBy?: string;
}

export interface DeleteReactionRequest {
    id: string;
    type: string;
    userId?: string;
}

export interface FlagOperationRequest {
    flagRequest: FlagRequest | null;
}

export interface GetManyMessagesRequest {
    type: string;
    id: string;
    ids?: Array<string>;
}

export interface GetMessageRequest {
    id: string;
}

export interface GetOGRequest {
    url?: string;
}

export interface GetReactionsRequest {
    id: string;
    limit?: number;
    offset?: number;
}

export interface GetRepliesRequest {
    parentId: string;
    idGte?: string;
    idGt?: string;
    idLte?: string;
    idLt?: string;
    createdAtAfterOrEqual?: string;
    createdAtAfter?: string;
    createdAtBeforeOrEqual?: string;
    createdAtBefore?: string;
    idAround?: string;
    createdAtAround?: string;
}

export interface MarkChannelsReadOperationRequest {
    markChannelsReadRequest: MarkChannelsReadRequest | null;
}

export interface MarkReadOperationRequest {
    type: string;
    id: string;
    markReadRequest: MarkReadRequest | null;
}

export interface MarkUnreadOperationRequest {
    type: string;
    id: string;
    markUnreadRequest: MarkUnreadRequest | null;
}

export interface QueryMessageFlagsOperationRequest {
    payload?: QueryMessageFlagsRequest;
}

export interface RunMessageActionRequest {
    id: string;
    messageActionRequest: MessageActionRequest | null;
}

export interface SearchOperationRequest {
    payload?: SearchRequest;
}

export interface SendMessageOperationRequest {
    type: string;
    id: string;
    sendMessageRequest: SendMessageRequest | null;
}

export interface SendReactionOperationRequest {
    id: string;
    sendReactionRequest: SendReactionRequest | null;
}

export interface TranslateMessageOperationRequest {
    id: string;
    translateMessageRequest: TranslateMessageRequest | null;
}

export interface UnflagRequest {
    flagRequest: FlagRequest | null;
}

export interface UpdateMessageOperationRequest {
    id: string;
    updateMessageRequest: UpdateMessageRequest | null;
}

export interface UpdateMessagePartialOperationRequest {
    id: string;
    updateMessagePartialRequest: UpdateMessagePartialRequest | null;
}

export interface UploadFileRequest {
    type: string;
    id: string;
    file?: string;
    user?: OnlyUserIDRequest;
}

export interface UploadImageRequest {
    type: string;
    id: string;
    file?: string;
    uploadSizes?: Array<ImageSizeRequest>;
    user?: OnlyUserIDRequest;
}

/**
 *
 */
export class MessagesApi extends runtime.BaseAPI {

    /**
     * Deletes previously uploaded file  Required permissions: - DeleteAttachment
     * Delete file
     */
    async deleteFileRaw(requestParameters: DeleteFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FileDeleteResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling deleteFile.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteFile.');
        }

        const queryParameters: any = {};

        if (requestParameters.url !== undefined) {
            queryParameters['url'] = requestParameters.url;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/file`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes previously uploaded file  Required permissions: - DeleteAttachment
     * Delete file
     */
    async deleteFile(requestParameters: DeleteFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FileDeleteResponse> {
        const response = await this.deleteFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes previously uploaded image  Required permissions: - DeleteAttachment
     * Delete image
     */
    async deleteImageRaw(requestParameters: DeleteImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FileDeleteResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling deleteImage.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteImage.');
        }

        const queryParameters: any = {};

        if (requestParameters.url !== undefined) {
            queryParameters['url'] = requestParameters.url;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/image`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes previously uploaded image  Required permissions: - DeleteAttachment
     * Delete image
     */
    async deleteImage(requestParameters: DeleteImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FileDeleteResponse> {
        const response = await this.deleteImageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes message  Sends events: - message.deleted  Required permissions: - DeleteMessage
     * Delete message
     */
    async deleteMessageRaw(requestParameters: DeleteMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteMessage.');
        }

        const queryParameters: any = {};

        if (requestParameters.hard !== undefined) {
            queryParameters['hard'] = requestParameters.hard;
        }

        if (requestParameters.deletedBy !== undefined) {
            queryParameters['deleted_by'] = requestParameters.deletedBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes message  Sends events: - message.deleted  Required permissions: - DeleteMessage
     * Delete message
     */
    async deleteMessage(requestParameters: DeleteMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageResponse> {
        const response = await this.deleteMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Removes user reaction from the message  Sends events: - reaction.deleted  Required permissions: - DeleteReaction
     * Delete reaction
     */
    async deleteReactionRaw(requestParameters: DeleteReactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReactionRemovalResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteReaction.');
        }

        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling deleteReaction.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}/reaction/{type}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Removes user reaction from the message  Sends events: - reaction.deleted  Required permissions: - DeleteReaction
     * Delete reaction
     */
    async deleteReaction(requestParameters: DeleteReactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReactionRemovalResponse> {
        const response = await this.deleteReactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser
     * Flag
     */
    async flagRaw(requestParameters: FlagOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FlagResponse>> {
        if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {
            throw new runtime.RequiredError('flagRequest','Required parameter requestParameters.flagRequest was null or undefined when calling flag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/moderation/flag`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.flagRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser
     * Flag
     */
    async flag(requestParameters: FlagOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FlagResponse> {
        const response = await this.flagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns list messages found by IDs  Required permissions: - ReadChannel
     * Get many messages
     */
    async getManyMessagesRaw(requestParameters: GetManyMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetManyMessagesResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling getManyMessages.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getManyMessages.');
        }

        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters['ids'] = requestParameters.ids.join(',');
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/messages`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns list messages found by IDs  Required permissions: - ReadChannel
     * Get many messages
     */
    async getManyMessages(requestParameters: GetManyMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetManyMessagesResponse> {
        const response = await this.getManyMessagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns message by ID  Required permissions: - ReadChannel
     * Get message
     */
    async getMessageRaw(requestParameters: GetMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageWithPendingMetadataResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getMessage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns message by ID  Required permissions: - ReadChannel
     * Get message
     */
    async getMessage(requestParameters: GetMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageWithPendingMetadataResponse> {
        const response = await this.getMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get an OpenGraph attachment for a link
     * Get OG
     */
    async getOGRaw(requestParameters: GetOGRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetOGResponse>> {
        const queryParameters: any = {};

        if (requestParameters.url !== undefined) {
            queryParameters['url'] = requestParameters.url;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/og`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get an OpenGraph attachment for a link
     * Get OG
     */
    async getOG(requestParameters: GetOGRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetOGResponse> {
        const response = await this.getOGRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns list of reactions of specific message  Required permissions: - ReadChannel
     * Get reactions
     */
    async getReactionsRaw(requestParameters: GetReactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetReactionsResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getReactions.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}/reactions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns list of reactions of specific message  Required permissions: - ReadChannel
     * Get reactions
     */
    async getReactions(requestParameters: GetReactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetReactionsResponse> {
        const response = await this.getReactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns replies (thread) of the message  Required permissions: - ReadChannel
     * Get replies
     */
    async getRepliesRaw(requestParameters: GetRepliesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRepliesResponse>> {
        if (requestParameters.parentId === null || requestParameters.parentId === undefined) {
            throw new runtime.RequiredError('parentId','Required parameter requestParameters.parentId was null or undefined when calling getReplies.');
        }

        const queryParameters: any = {};

        if (requestParameters.idGte !== undefined) {
            queryParameters['id_gte'] = requestParameters.idGte;
        }

        if (requestParameters.idGt !== undefined) {
            queryParameters['id_gt'] = requestParameters.idGt;
        }

        if (requestParameters.idLte !== undefined) {
            queryParameters['id_lte'] = requestParameters.idLte;
        }

        if (requestParameters.idLt !== undefined) {
            queryParameters['id_lt'] = requestParameters.idLt;
        }

        if (requestParameters.createdAtAfterOrEqual !== undefined) {
            queryParameters['created_at_after_or_equal'] = requestParameters.createdAtAfterOrEqual;
        }

        if (requestParameters.createdAtAfter !== undefined) {
            queryParameters['created_at_after'] = requestParameters.createdAtAfter;
        }

        if (requestParameters.createdAtBeforeOrEqual !== undefined) {
            queryParameters['created_at_before_or_equal'] = requestParameters.createdAtBeforeOrEqual;
        }

        if (requestParameters.createdAtBefore !== undefined) {
            queryParameters['created_at_before'] = requestParameters.createdAtBefore;
        }

        if (requestParameters.idAround !== undefined) {
            queryParameters['id_around'] = requestParameters.idAround;
        }

        if (requestParameters.createdAtAround !== undefined) {
            queryParameters['created_at_around'] = requestParameters.createdAtAround;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{parent_id}/replies`.replace(`{${"parent_id"}}`, encodeURIComponent(String(requestParameters.parentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns replies (thread) of the message  Required permissions: - ReadChannel
     * Get replies
     */
    async getReplies(requestParameters: GetRepliesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRepliesResponse> {
        const response = await this.getRepliesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel
     * Mark channels as read
     */
    async markChannelsReadRaw(requestParameters: MarkChannelsReadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MarkReadResponse>> {
        if (requestParameters.markChannelsReadRequest === null || requestParameters.markChannelsReadRequest === undefined) {
            throw new runtime.RequiredError('markChannelsReadRequest','Required parameter requestParameters.markChannelsReadRequest was null or undefined when calling markChannelsRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/read`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.markChannelsReadRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel
     * Mark channels as read
     */
    async markChannelsRead(requestParameters: MarkChannelsReadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MarkReadResponse> {
        const response = await this.markChannelsReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel
     * Mark read
     */
    async markReadRaw(requestParameters: MarkReadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MarkReadResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling markRead.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling markRead.');
        }

        if (requestParameters.markReadRequest === null || requestParameters.markReadRequest === undefined) {
            throw new runtime.RequiredError('markReadRequest','Required parameter requestParameters.markReadRequest was null or undefined when calling markRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/read`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.markReadRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel
     * Mark read
     */
    async markRead(requestParameters: MarkReadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MarkReadResponse> {
        const response = await this.markReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Marks channel as unread from a specific message  Required permissions: - ReadChannel
     * Mark unread
     */
    async markUnreadRaw(requestParameters: MarkUnreadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling markUnread.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling markUnread.');
        }

        if (requestParameters.markUnreadRequest === null || requestParameters.markUnreadRequest === undefined) {
            throw new runtime.RequiredError('markUnreadRequest','Required parameter requestParameters.markUnreadRequest was null or undefined when calling markUnread.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/unread`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.markUnreadRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Marks channel as unread from a specific message  Required permissions: - ReadChannel
     * Mark unread
     */
    async markUnread(requestParameters: MarkUnreadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.markUnreadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find and filter message flags  Required permissions: - ReadMessageFlags
     * Query Message Flags
     */
    async queryMessageFlagsRaw(requestParameters: QueryMessageFlagsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryMessageFlagsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.payload !== undefined) {
            queryParameters['payload'] = requestParameters.payload;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/moderation/flags/message`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find and filter message flags  Required permissions: - ReadMessageFlags
     * Query Message Flags
     */
    async queryMessageFlags(requestParameters: QueryMessageFlagsOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryMessageFlagsResponse> {
        const response = await this.queryMessageFlagsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Executes message command action with given parameters  Sends events: - message.new  Required permissions: - RunMessageAction
     * Run message command action
     */
    async runMessageActionRaw(requestParameters: RunMessageActionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling runMessageAction.');
        }

        if (requestParameters.messageActionRequest === null || requestParameters.messageActionRequest === undefined) {
            throw new runtime.RequiredError('messageActionRequest','Required parameter requestParameters.messageActionRequest was null or undefined when calling runMessageAction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}/action`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.messageActionRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Executes message command action with given parameters  Sends events: - message.new  Required permissions: - RunMessageAction
     * Run message command action
     */
    async runMessageAction(requestParameters: RunMessageActionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageResponse> {
        const response = await this.runMessageActionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search messages across channels  Required permissions: - ReadChannel
     * Search messages
     */
    async searchRaw(requestParameters: SearchOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchResponse>> {
        const queryParameters: any = {};

        if (requestParameters.payload !== undefined) {
            queryParameters['payload'] = requestParameters.payload;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Search messages across channels  Required permissions: - ReadChannel
     * Search messages
     */
    async search(requestParameters: SearchOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchResponse> {
        const response = await this.searchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sends new message to the specified channel  Sends events: - message.new - message.updated  Required permissions: - AddLinks - CreateMessage - PinMessage - SkipChannelCooldown - SkipMessageModeration - UseFrozenChannel
     * Send new message
     */
    async sendMessageRaw(requestParameters: SendMessageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageWithPendingMetadataResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling sendMessage.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sendMessage.');
        }

        if (requestParameters.sendMessageRequest === null || requestParameters.sendMessageRequest === undefined) {
            throw new runtime.RequiredError('sendMessageRequest','Required parameter requestParameters.sendMessageRequest was null or undefined when calling sendMessage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/message`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.sendMessageRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sends new message to the specified channel  Sends events: - message.new - message.updated  Required permissions: - AddLinks - CreateMessage - PinMessage - SkipChannelCooldown - SkipMessageModeration - UseFrozenChannel
     * Send new message
     */
    async sendMessage(requestParameters: SendMessageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageWithPendingMetadataResponse> {
        const response = await this.sendMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sends reaction to specified message  Sends events: - reaction.new - reaction.updated  Required permissions: - CreateReaction - UseFrozenChannel
     * Send reaction
     */
    async sendReactionRaw(requestParameters: SendReactionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReactionResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sendReaction.');
        }

        if (requestParameters.sendReactionRequest === null || requestParameters.sendReactionRequest === undefined) {
            throw new runtime.RequiredError('sendReactionRequest','Required parameter requestParameters.sendReactionRequest was null or undefined when calling sendReaction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}/reaction`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.sendReactionRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sends reaction to specified message  Sends events: - reaction.new - reaction.updated  Required permissions: - CreateReaction - UseFrozenChannel
     * Send reaction
     */
    async sendReaction(requestParameters: SendReactionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReactionResponse> {
        const response = await this.sendReactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Translates message to a given language using automated translation software  Sends events: - message.updated  Required permissions: - ReadChannel
     * Translate message
     */
    async translateMessageRaw(requestParameters: TranslateMessageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling translateMessage.');
        }

        if (requestParameters.translateMessageRequest === null || requestParameters.translateMessageRequest === undefined) {
            throw new runtime.RequiredError('translateMessageRequest','Required parameter requestParameters.translateMessageRequest was null or undefined when calling translateMessage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}/translate`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.translateMessageRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Translates message to a given language using automated translation software  Sends events: - message.updated  Required permissions: - ReadChannel
     * Translate message
     */
    async translateMessage(requestParameters: TranslateMessageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageResponse> {
        const response = await this.translateMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser
     * Unflag
     */
    async unflagRaw(requestParameters: UnflagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FlagResponse>> {
        if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {
            throw new runtime.RequiredError('flagRequest','Required parameter requestParameters.flagRequest was null or undefined when calling unflag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/moderation/unflag`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.flagRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser
     * Unflag
     */
    async unflag(requestParameters: UnflagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FlagResponse> {
        const response = await this.unflagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates message with new data  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage
     * Update message
     */
    async updateMessageRaw(requestParameters: UpdateMessageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateMessage.');
        }

        if (requestParameters.updateMessageRequest === null || requestParameters.updateMessageRequest === undefined) {
            throw new runtime.RequiredError('updateMessageRequest','Required parameter requestParameters.updateMessageRequest was null or undefined when calling updateMessage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateMessageRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates message with new data  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage
     * Update message
     */
    async updateMessage(requestParameters: UpdateMessageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageResponse> {
        const response = await this.updateMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates certain fields of the message  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage
     * Partially message update
     */
    async updateMessagePartialRaw(requestParameters: UpdateMessagePartialOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateMessagePartial.');
        }

        if (requestParameters.updateMessagePartialRequest === null || requestParameters.updateMessagePartialRequest === undefined) {
            throw new runtime.RequiredError('updateMessagePartialRequest','Required parameter requestParameters.updateMessagePartialRequest was null or undefined when calling updateMessagePartial.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/messages/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateMessagePartialRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates certain fields of the message  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage
     * Partially message update
     */
    async updateMessagePartial(requestParameters: UpdateMessagePartialOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageResponse> {
        const response = await this.updateMessagePartialRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Uploads file  Required permissions: - UploadAttachment
     * Upload file
     */
    async uploadFileRaw(requestParameters: UploadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FileUploadResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling uploadFile.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling uploadFile.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        if (requestParameters.user !== undefined) {

            formParams.append('user', new Blob([JSON.stringify(requestParameters.user)], { type: "application/json", }));
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/file`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Uploads file  Required permissions: - UploadAttachment
     * Upload file
     */
    async uploadFile(requestParameters: UploadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FileUploadResponse> {
        const response = await this.uploadFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Uploads image  Required permissions: - UploadAttachment
     * Upload image
     */
    async uploadImageRaw(requestParameters: UploadImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImageUploadResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling uploadImage.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling uploadImage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        if (requestParameters.uploadSizes) {
            formParams.append('upload_sizes', requestParameters.uploadSizes.join(runtime.COLLECTION_FORMATS["csv"]));
        }

        if (requestParameters.user !== undefined) {

            formParams.append('user', new Blob([JSON.stringify(requestParameters.user)], { type: "application/json", }));
        }

        const response = await this.request({
            path: `/channels/{type}/{id}/image`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Uploads image  Required permissions: - UploadAttachment
     * Upload image
     */
    async uploadImage(requestParameters: UploadImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImageUploadResponse> {
        const response = await this.uploadImageRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
