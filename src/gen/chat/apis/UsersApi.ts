/* tslint:disable */
/* eslint-disable */
/**
 * Stream Chat API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v92.7.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  APIError,
  BanRequest,
  ConnectRequest,
  DeactivateUserRequest,
  DeactivateUserResponse,
  DeactivateUsersRequest,
  DeactivateUsersResponse,
  DeleteUserResponse,
  DeleteUsersRequest,
  DeleteUsersResponse,
  ExportUserResponse,
  ExportUsersRequest,
  ExportUsersResponse,
  FlagRequest,
  FlagResponse,
  GuestRequest,
  GuestResponse,
  MuteUserRequest,
  MuteUserResponse,
  QueryBannedUsersRequest,
  QueryBannedUsersResponse,
  QueryUsersRequest,
  ReactivateUserRequest,
  ReactivateUserResponse,
  ReactivateUsersRequest,
  ReactivateUsersResponse,
  Response,
  RestoreUsersRequest,
  UnmuteResponse,
  UnmuteUserRequest,
  UpdateUserPartialRequest,
  UpdateUsersRequest,
  UpdateUsersResponse,
  UsersResponse,
} from '../models';

export interface BanOperationRequest {
    banRequest: BanRequest | null;
}

export interface ConnectOperationRequest {
    json?: ConnectRequest;
}

export interface CreateGuestRequest {
    guestRequest: GuestRequest | null;
}

export interface DeactivateUserOperationRequest {
    userId: string;
    deactivateUserRequest: DeactivateUserRequest | null;
}

export interface DeactivateUsersOperationRequest {
    deactivateUsersRequest: DeactivateUsersRequest | null;
}

export interface DeleteUserRequest {
    userId: string;
    markMessagesDeleted?: boolean;
    hardDelete?: boolean;
    deleteConversationChannels?: boolean;
}

export interface DeleteUsersOperationRequest {
    deleteUsersRequest: DeleteUsersRequest | null;
}

export interface ExportUserRequest {
    userId: string;
}

export interface ExportUsersOperationRequest {
    exportUsersRequest: ExportUsersRequest | null;
}

export interface FlagOperationRequest {
    flagRequest: FlagRequest | null;
}

export interface LongPollRequest {
    json?: ConnectRequest;
    connectionId?: string;
}

export interface MuteUserOperationRequest {
    muteUserRequest: MuteUserRequest | null;
}

export interface QueryBannedUsersOperationRequest {
    payload?: QueryBannedUsersRequest;
}

export interface QueryUsersOperationRequest {
    payload?: QueryUsersRequest;
}

export interface ReactivateUserOperationRequest {
    userId: string;
    reactivateUserRequest: ReactivateUserRequest | null;
}

export interface ReactivateUsersOperationRequest {
    reactivateUsersRequest: ReactivateUsersRequest | null;
}

export interface RestoreUsersOperationRequest {
    restoreUsersRequest: RestoreUsersRequest | null;
}

export interface UnbanRequest {
    targetUserId?: string;
    type?: string;
    id?: string;
    createdBy?: string;
}

export interface UnflagRequest {
    flagRequest: FlagRequest | null;
}

export interface UnmuteUserOperationRequest {
    unmuteUserRequest: UnmuteUserRequest | null;
}

export interface UpdateUsersOperationRequest {
    updateUsersRequest: UpdateUsersRequest | null;
}

export interface UpdateUsersPartialRequest {
    updateUserPartialRequest: UpdateUserPartialRequest | null;
}

/**
 * 
 */
export class UsersApi extends runtime.BaseAPI {

    /**
     * Restricts user activity either in specific channel or globally  Sends events: - user.banned  Required permissions: - BanChannelMember - BanUser 
     * Ban user
     */
    async banRaw(requestParameters: BanOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.banRequest === null || requestParameters.banRequest === undefined) {
            throw new runtime.RequiredError('banRequest','Required parameter requestParameters.banRequest was null or undefined when calling ban.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/moderation/ban`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.banRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Restricts user activity either in specific channel or globally  Sends events: - user.banned  Required permissions: - BanChannelMember - BanUser 
     * Ban user
     */
    async ban(requestParameters: BanOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.banRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Establishes WebSocket connection for user  Sends events: - user.updated 
     * Connect (WebSocket)
     */
    async connectRaw(requestParameters: ConnectOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters.json !== undefined) {
            queryParameters['json'] = requestParameters.json;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/connect`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Establishes WebSocket connection for user  Sends events: - user.updated 
     * Connect (WebSocket)
     */
    async connect(requestParameters: ConnectOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.connectRaw(requestParameters, initOverrides);
    }

    /**
     * Creates guest user 
     * Create guest
     */
    async createGuestRaw(requestParameters: CreateGuestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GuestResponse>> {
        if (requestParameters.guestRequest === null || requestParameters.guestRequest === undefined) {
            throw new runtime.RequiredError('guestRequest','Required parameter requestParameters.guestRequest was null or undefined when calling createGuest.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/guest`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.guestRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates guest user 
     * Create guest
     */
    async createGuest(requestParameters: CreateGuestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GuestResponse> {
        const response = await this.createGuestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deactivates user with possibility to activate it back  Sends events: - user.deactivated 
     * Deactivate user
     */
    async deactivateUserRaw(requestParameters: DeactivateUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeactivateUserResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling deactivateUser.');
        }

        if (requestParameters.deactivateUserRequest === null || requestParameters.deactivateUserRequest === undefined) {
            throw new runtime.RequiredError('deactivateUserRequest','Required parameter requestParameters.deactivateUserRequest was null or undefined when calling deactivateUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users/{user_id}/deactivate`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.deactivateUserRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deactivates user with possibility to activate it back  Sends events: - user.deactivated 
     * Deactivate user
     */
    async deactivateUser(requestParameters: DeactivateUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeactivateUserResponse> {
        const response = await this.deactivateUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deactivate users in batches  Sends events: - user.deactivated 
     * Deactivate users
     */
    async deactivateUsersRaw(requestParameters: DeactivateUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeactivateUsersResponse>> {
        if (requestParameters.deactivateUsersRequest === null || requestParameters.deactivateUsersRequest === undefined) {
            throw new runtime.RequiredError('deactivateUsersRequest','Required parameter requestParameters.deactivateUsersRequest was null or undefined when calling deactivateUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users/deactivate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.deactivateUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deactivate users in batches  Sends events: - user.deactivated 
     * Deactivate users
     */
    async deactivateUsers(requestParameters: DeactivateUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeactivateUsersResponse> {
        const response = await this.deactivateUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes user and optionally all their belongings. The Endpoint is deprecated, please use \'Delete Users\' endpoint instead  Sends events: - channel.deleted - message.deleted - user.deleted 
     * Delete user
     */
    async deleteUserRaw(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteUserResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling deleteUser.');
        }

        const queryParameters: any = {};

        if (requestParameters.markMessagesDeleted !== undefined) {
            queryParameters['mark_messages_deleted'] = requestParameters.markMessagesDeleted;
        }

        if (requestParameters.hardDelete !== undefined) {
            queryParameters['hard_delete'] = requestParameters.hardDelete;
        }

        if (requestParameters.deleteConversationChannels !== undefined) {
            queryParameters['delete_conversation_channels'] = requestParameters.deleteConversationChannels;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users/{user_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes user and optionally all their belongings. The Endpoint is deprecated, please use \'Delete Users\' endpoint instead  Sends events: - channel.deleted - message.deleted - user.deleted 
     * Delete user
     */
    async deleteUser(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteUserResponse> {
        const response = await this.deleteUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes users and optionally all their belongings asynchronously.  Sends events: - channel.deleted - user.deleted 
     * Delete Users
     */
    async deleteUsersRaw(requestParameters: DeleteUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteUsersResponse>> {
        if (requestParameters.deleteUsersRequest === null || requestParameters.deleteUsersRequest === undefined) {
            throw new runtime.RequiredError('deleteUsersRequest','Required parameter requestParameters.deleteUsersRequest was null or undefined when calling deleteUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users/delete`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.deleteUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes users and optionally all their belongings asynchronously.  Sends events: - channel.deleted - user.deleted 
     * Delete Users
     */
    async deleteUsers(requestParameters: DeleteUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteUsersResponse> {
        const response = await this.deleteUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Exports the user\'s profile, reactions and messages. Raises an error if a user has more than 10k messages or reactions 
     * Export user
     */
    async exportUserRaw(requestParameters: ExportUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportUserResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling exportUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users/{user_id}/export`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Exports the user\'s profile, reactions and messages. Raises an error if a user has more than 10k messages or reactions 
     * Export user
     */
    async exportUser(requestParameters: ExportUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportUserResponse> {
        const response = await this.exportUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Exports user profile, reactions and messages for list of given users 
     * Export users
     */
    async exportUsersRaw(requestParameters: ExportUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportUsersResponse>> {
        if (requestParameters.exportUsersRequest === null || requestParameters.exportUsersRequest === undefined) {
            throw new runtime.RequiredError('exportUsersRequest','Required parameter requestParameters.exportUsersRequest was null or undefined when calling exportUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/export/users`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.exportUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Exports user profile, reactions and messages for list of given users 
     * Export users
     */
    async exportUsers(requestParameters: ExportUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportUsersResponse> {
        const response = await this.exportUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser 
     * Flag
     */
    async flagRaw(requestParameters: FlagOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FlagResponse>> {
        if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {
            throw new runtime.RequiredError('flagRequest','Required parameter requestParameters.flagRequest was null or undefined when calling flag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/moderation/flag`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.flagRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser 
     * Flag
     */
    async flag(requestParameters: FlagOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FlagResponse> {
        const response = await this.flagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * WebSocket fallback transport endpoint  Sends events: - user.updated 
     * Long Poll (Transport)
     */
    async longPollRaw(requestParameters: LongPollRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters.json !== undefined) {
            queryParameters['json'] = requestParameters.json;
        }

        if (requestParameters.connectionId !== undefined) {
            queryParameters['connection_id'] = requestParameters.connectionId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/longpoll`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * WebSocket fallback transport endpoint  Sends events: - user.updated 
     * Long Poll (Transport)
     */
    async longPoll(requestParameters: LongPollRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.longPollRaw(requestParameters, initOverrides);
    }

    /**
     * Mutes one or several users  Sends events: - user.muted  Required permissions: - MuteUser 
     * Mute user
     */
    async muteUserRaw(requestParameters: MuteUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MuteUserResponse>> {
        if (requestParameters.muteUserRequest === null || requestParameters.muteUserRequest === undefined) {
            throw new runtime.RequiredError('muteUserRequest','Required parameter requestParameters.muteUserRequest was null or undefined when calling muteUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/moderation/mute`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.muteUserRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Mutes one or several users  Sends events: - user.muted  Required permissions: - MuteUser 
     * Mute user
     */
    async muteUser(requestParameters: MuteUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MuteUserResponse> {
        const response = await this.muteUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find and filter channel scoped or global user bans  Required permissions: - ReadChannel 
     * Query Banned Users
     */
    async queryBannedUsersRaw(requestParameters: QueryBannedUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryBannedUsersResponse>> {
        const queryParameters: any = {};

        if (requestParameters.payload !== undefined) {
            queryParameters['payload'] = requestParameters.payload;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/query_banned_users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find and filter channel scoped or global user bans  Required permissions: - ReadChannel 
     * Query Banned Users
     */
    async queryBannedUsers(requestParameters: QueryBannedUsersOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryBannedUsersResponse> {
        const response = await this.queryBannedUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find and filter users  Required permissions: - SearchUser 
     * Query users
     */
    async queryUsersRaw(requestParameters: QueryUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsersResponse>> {
        const queryParameters: any = {};

        if (requestParameters.payload !== undefined) {
            queryParameters['payload'] = requestParameters.payload;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find and filter users  Required permissions: - SearchUser 
     * Query users
     */
    async queryUsers(requestParameters: QueryUsersOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsersResponse> {
        const response = await this.queryUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Activates user who\'s been deactivated previously  Sends events: - user.reactivated 
     * Reactivate user
     */
    async reactivateUserRaw(requestParameters: ReactivateUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReactivateUserResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling reactivateUser.');
        }

        if (requestParameters.reactivateUserRequest === null || requestParameters.reactivateUserRequest === undefined) {
            throw new runtime.RequiredError('reactivateUserRequest','Required parameter requestParameters.reactivateUserRequest was null or undefined when calling reactivateUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users/{user_id}/reactivate`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.reactivateUserRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Activates user who\'s been deactivated previously  Sends events: - user.reactivated 
     * Reactivate user
     */
    async reactivateUser(requestParameters: ReactivateUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReactivateUserResponse> {
        const response = await this.reactivateUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reactivate users in batches  Sends events: - user.reactivated 
     * Reactivate users
     */
    async reactivateUsersRaw(requestParameters: ReactivateUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReactivateUsersResponse>> {
        if (requestParameters.reactivateUsersRequest === null || requestParameters.reactivateUsersRequest === undefined) {
            throw new runtime.RequiredError('reactivateUsersRequest','Required parameter requestParameters.reactivateUsersRequest was null or undefined when calling reactivateUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users/reactivate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.reactivateUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Reactivate users in batches  Sends events: - user.reactivated 
     * Reactivate users
     */
    async reactivateUsers(requestParameters: ReactivateUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReactivateUsersResponse> {
        const response = await this.reactivateUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Restore soft deleted users 
     * Restore users
     */
    async restoreUsersRaw(requestParameters: RestoreUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.restoreUsersRequest === null || requestParameters.restoreUsersRequest === undefined) {
            throw new runtime.RequiredError('restoreUsersRequest','Required parameter requestParameters.restoreUsersRequest was null or undefined when calling restoreUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users/restore`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restoreUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Restore soft deleted users 
     * Restore users
     */
    async restoreUsers(requestParameters: RestoreUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.restoreUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Removes previously applied ban  Sends events: - user.unbanned  Required permissions: - BanChannelMember - BanUser 
     * Unban user
     */
    async unbanRaw(requestParameters: UnbanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        const queryParameters: any = {};

        if (requestParameters.targetUserId !== undefined) {
            queryParameters['target_user_id'] = requestParameters.targetUserId;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.createdBy !== undefined) {
            queryParameters['created_by'] = requestParameters.createdBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/moderation/ban`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Removes previously applied ban  Sends events: - user.unbanned  Required permissions: - BanChannelMember - BanUser 
     * Unban user
     */
    async unban(requestParameters: UnbanRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.unbanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser 
     * Unflag
     */
    async unflagRaw(requestParameters: UnflagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FlagResponse>> {
        if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {
            throw new runtime.RequiredError('flagRequest','Required parameter requestParameters.flagRequest was null or undefined when calling unflag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/moderation/unflag`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.flagRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser 
     * Unflag
     */
    async unflag(requestParameters: UnflagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FlagResponse> {
        const response = await this.unflagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unmutes previously muted user  Sends events: - user.unmuted  Required permissions: - MuteUser 
     * Unmute user
     */
    async unmuteUserRaw(requestParameters: UnmuteUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UnmuteResponse>> {
        if (requestParameters.unmuteUserRequest === null || requestParameters.unmuteUserRequest === undefined) {
            throw new runtime.RequiredError('unmuteUserRequest','Required parameter requestParameters.unmuteUserRequest was null or undefined when calling unmuteUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/moderation/unmute`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.unmuteUserRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Unmutes previously muted user  Sends events: - user.unmuted  Required permissions: - MuteUser 
     * Unmute user
     */
    async unmuteUser(requestParameters: UnmuteUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UnmuteResponse> {
        const response = await this.unmuteUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update or create users in bulk  Sends events: - user.updated 
     * Upsert users
     */
    async updateUsersRaw(requestParameters: UpdateUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateUsersResponse>> {
        if (requestParameters.updateUsersRequest === null || requestParameters.updateUsersRequest === undefined) {
            throw new runtime.RequiredError('updateUsersRequest','Required parameter requestParameters.updateUsersRequest was null or undefined when calling updateUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update or create users in bulk  Sends events: - user.updated 
     * Upsert users
     */
    async updateUsers(requestParameters: UpdateUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateUsersResponse> {
        const response = await this.updateUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates certain fields of the user  Sends events: - user.presence.changed - user.updated 
     * Partially update user
     */
    async updateUsersPartialRaw(requestParameters: UpdateUsersPartialRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateUsersResponse>> {
        if (requestParameters.updateUserPartialRequest === null || requestParameters.updateUserPartialRequest === undefined) {
            throw new runtime.RequiredError('updateUserPartialRequest','Required parameter requestParameters.updateUserPartialRequest was null or undefined when calling updateUsersPartial.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/users`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateUserPartialRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates certain fields of the user  Sends events: - user.presence.changed - user.updated 
     * Partially update user
     */
    async updateUsersPartial(requestParameters: UpdateUsersPartialRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateUsersResponse> {
        const response = await this.updateUsersPartialRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
