/* tslint:disable */
/* eslint-disable */
/**
 * Stream Video API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v89.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  APIError,
  AcceptCallResponse,
  BlockUserRequest,
  BlockUserResponse,
  CreateDeviceRequest,
  CreateGuestRequest,
  CreateGuestResponse,
  EndCallResponse,
  GetCallResponse,
  GetEdgesResponse,
  GetOrCreateCallRequest,
  GetOrCreateCallResponse,
  GoLiveRequest,
  GoLiveResponse,
  JoinCallRequest,
  JoinCallResponse,
  ListDevicesResponse,
  ListRecordingsResponse,
  MuteUsersRequest,
  MuteUsersResponse,
  PinRequest,
  PinResponse,
  QueryCallsRequest,
  QueryCallsResponse,
  QueryMembersRequest,
  QueryMembersResponse,
  RejectCallResponse,
  RequestPermissionRequest,
  RequestPermissionResponse,
  Response,
  SendEventRequest,
  SendEventResponse,
  SendReactionRequest,
  SendReactionResponse,
  StartHLSBroadcastingResponse,
  StartRecordingResponse,
  StartTranscriptionResponse,
  StopHLSBroadcastingResponse,
  StopLiveResponse,
  StopRecordingResponse,
  StopTranscriptionResponse,
  UnblockUserRequest,
  UnblockUserResponse,
  UnpinRequest,
  UnpinResponse,
  UpdateCallMembersRequest,
  UpdateCallMembersResponse,
  UpdateCallRequest,
  UpdateCallResponse,
  UpdateUserPermissionsRequest,
  UpdateUserPermissionsResponse,
  WSAuthMessageRequest,
} from '../models';

export interface AcceptCallRequest {
    type: string;
    id: string;
}

export interface BlockUserOperationRequest {
    type: string;
    id: string;
    blockUserRequest: BlockUserRequest | null;
}

export interface CreateDeviceOperationRequest {
    createDeviceRequest: CreateDeviceRequest | null;
}

export interface CreateGuestOperationRequest {
    createGuestRequest: CreateGuestRequest | null;
}

export interface DeleteDeviceRequest {
    id?: string;
    userId?: string;
}

export interface EndCallRequest {
    type: string;
    id: string;
}

export interface GetCallRequest {
    type: string;
    id: string;
    connectionId?: string;
    membersLimit?: number;
    ring?: boolean;
    notify?: boolean;
}

export interface GetOrCreateCallOperationRequest {
    type: string;
    id: string;
    getOrCreateCallRequest: GetOrCreateCallRequest | null;
    connectionId?: string;
}

export interface GoLiveOperationRequest {
    type: string;
    id: string;
    goLiveRequest: GoLiveRequest | null;
}

export interface JoinCallOperationRequest {
    type: string;
    id: string;
    joinCallRequest: JoinCallRequest | null;
    connectionId?: string;
}

export interface ListDevicesRequest {
    userId?: string;
}

export interface ListRecordingsTypeId0Request {
    type: string;
    id: string;
}

export interface ListRecordingsTypeIdSession1Request {
    type: string;
    id: string;
    session: string;
}

export interface MuteUsersOperationRequest {
    type: string;
    id: string;
    muteUsersRequest: MuteUsersRequest | null;
}

export interface QueryCallsOperationRequest {
    queryCallsRequest: QueryCallsRequest | null;
    connectionId?: string;
}

export interface QueryMembersOperationRequest {
    queryMembersRequest: QueryMembersRequest | null;
}

export interface RejectCallRequest {
    type: string;
    id: string;
}

export interface RequestPermissionOperationRequest {
    type: string;
    id: string;
    requestPermissionRequest: RequestPermissionRequest | null;
}

export interface SendEventOperationRequest {
    type: string;
    id: string;
    sendEventRequest: SendEventRequest | null;
}

export interface SendVideoReactionRequest {
    type: string;
    id: string;
    sendReactionRequest: SendReactionRequest | null;
}

export interface StartHLSBroadcastingRequest {
    type: string;
    id: string;
}

export interface StartRecordingRequest {
    type: string;
    id: string;
}

export interface StartTranscriptionRequest {
    type: string;
    id: string;
}

export interface StopHLSBroadcastingRequest {
    type: string;
    id: string;
}

export interface StopLiveRequest {
    type: string;
    id: string;
}

export interface StopRecordingRequest {
    type: string;
    id: string;
}

export interface StopTranscriptionRequest {
    type: string;
    id: string;
}

export interface UnblockUserOperationRequest {
    type: string;
    id: string;
    unblockUserRequest: UnblockUserRequest | null;
}

export interface UpdateCallOperationRequest {
    type: string;
    id: string;
    updateCallRequest: UpdateCallRequest | null;
}

export interface UpdateCallMembersOperationRequest {
    type: string;
    id: string;
    updateCallMembersRequest: UpdateCallMembersRequest | null;
}

export interface UpdateUserPermissionsOperationRequest {
    type: string;
    id: string;
    updateUserPermissionsRequest: UpdateUserPermissionsRequest | null;
}

export interface VideoConnectRequest {
    wSAuthMessageRequest: WSAuthMessageRequest | null;
}

export interface VideoPinRequest {
    type: string;
    id: string;
    pinRequest: PinRequest | null;
}

export interface VideoUnpinRequest {
    type: string;
    id: string;
    unpinRequest: UnpinRequest | null;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     *   Sends events: - call.accepted  Required permissions: - JoinCall 
     * Accept Call
     */
    async acceptCallRaw(requestParameters: AcceptCallRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AcceptCallResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling acceptCall.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling acceptCall.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/accept`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *   Sends events: - call.accepted  Required permissions: - JoinCall 
     * Accept Call
     */
    async acceptCall(requestParameters: AcceptCallRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AcceptCallResponse> {
        const response = await this.acceptCallRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Block a user, preventing them from joining the call until they are unblocked.  Sends events: - call.blocked_user  Required permissions: - BlockUser 
     * Block user on a call
     */
    async blockUserRaw(requestParameters: BlockUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockUserResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling blockUser.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling blockUser.');
        }

        if (requestParameters.blockUserRequest === null || requestParameters.blockUserRequest === undefined) {
            throw new runtime.RequiredError('blockUserRequest','Required parameter requestParameters.blockUserRequest was null or undefined when calling blockUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/block`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.blockUserRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Block a user, preventing them from joining the call until they are unblocked.  Sends events: - call.blocked_user  Required permissions: - BlockUser 
     * Block user on a call
     */
    async blockUser(requestParameters: BlockUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockUserResponse> {
        const response = await this.blockUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Adds a new device to a user, if the same device already exists the call will have no effect 
     * Create device
     */
    async createDeviceRaw(requestParameters: CreateDeviceOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.createDeviceRequest === null || requestParameters.createDeviceRequest === undefined) {
            throw new runtime.RequiredError('createDeviceRequest','Required parameter requestParameters.createDeviceRequest was null or undefined when calling createDevice.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/devices`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createDeviceRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Adds a new device to a user, if the same device already exists the call will have no effect 
     * Create device
     */
    async createDevice(requestParameters: CreateDeviceOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.createDeviceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  
     * Create Guest
     */
    async createGuestRaw(requestParameters: CreateGuestOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateGuestResponse>> {
        if (requestParameters.createGuestRequest === null || requestParameters.createGuestRequest === undefined) {
            throw new runtime.RequiredError('createGuestRequest','Required parameter requestParameters.createGuestRequest was null or undefined when calling createGuest.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/guest`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createGuestRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *  
     * Create Guest
     */
    async createGuest(requestParameters: CreateGuestOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateGuestResponse> {
        const response = await this.createGuestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes one device 
     * Delete device
     */
    async deleteDeviceRaw(requestParameters: DeleteDeviceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        const queryParameters: any = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/devices`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes one device 
     * Delete device
     */
    async deleteDevice(requestParameters: DeleteDeviceRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.deleteDeviceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *   Sends events: - call.ended  Required permissions: - EndCall 
     * End call
     */
    async endCallRaw(requestParameters: EndCallRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EndCallResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling endCall.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling endCall.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/mark_ended`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *   Sends events: - call.ended  Required permissions: - EndCall 
     * End call
     */
    async endCall(requestParameters: EndCallRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EndCallResponse> {
        const response = await this.endCallRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *   Required permissions: - ReadCall 
     * Get Call
     */
    async getCallRaw(requestParameters: GetCallRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCallResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling getCall.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getCall.');
        }

        const queryParameters: any = {};

        if (requestParameters.connectionId !== undefined) {
            queryParameters['connection_id'] = requestParameters.connectionId;
        }

        if (requestParameters.membersLimit !== undefined) {
            queryParameters['members_limit'] = requestParameters.membersLimit;
        }

        if (requestParameters.ring !== undefined) {
            queryParameters['ring'] = requestParameters.ring;
        }

        if (requestParameters.notify !== undefined) {
            queryParameters['notify'] = requestParameters.notify;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *   Required permissions: - ReadCall 
     * Get Call
     */
    async getCall(requestParameters: GetCallRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCallResponse> {
        const response = await this.getCallRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the list of all edges available for video calls. 
     * Get Edges
     */
    async getEdgesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetEdgesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/edges`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the list of all edges available for video calls. 
     * Get Edges
     */
    async getEdges(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetEdgesResponse> {
        const response = await this.getEdgesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Gets or creates a new call  Sends events: - call.created - call.notification - call.ring  Required permissions: - CreateCall - ReadCall - UpdateCallSettings 
     * Get or create a call
     */
    async getOrCreateCallRaw(requestParameters: GetOrCreateCallOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetOrCreateCallResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling getOrCreateCall.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getOrCreateCall.');
        }

        if (requestParameters.getOrCreateCallRequest === null || requestParameters.getOrCreateCallRequest === undefined) {
            throw new runtime.RequiredError('getOrCreateCallRequest','Required parameter requestParameters.getOrCreateCallRequest was null or undefined when calling getOrCreateCall.');
        }

        const queryParameters: any = {};

        if (requestParameters.connectionId !== undefined) {
            queryParameters['connection_id'] = requestParameters.connectionId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.getOrCreateCallRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets or creates a new call  Sends events: - call.created - call.notification - call.ring  Required permissions: - CreateCall - ReadCall - UpdateCallSettings 
     * Get or create a call
     */
    async getOrCreateCall(requestParameters: GetOrCreateCallOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetOrCreateCallResponse> {
        const response = await this.getOrCreateCallRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *   Sends events: - call.live_started  Required permissions: - UpdateCall 
     * Set call as live
     */
    async goLiveRaw(requestParameters: GoLiveOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GoLiveResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling goLive.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling goLive.');
        }

        if (requestParameters.goLiveRequest === null || requestParameters.goLiveRequest === undefined) {
            throw new runtime.RequiredError('goLiveRequest','Required parameter requestParameters.goLiveRequest was null or undefined when calling goLive.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/go_live`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.goLiveRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *   Sends events: - call.live_started  Required permissions: - UpdateCall 
     * Set call as live
     */
    async goLive(requestParameters: GoLiveOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GoLiveResponse> {
        const response = await this.goLiveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Request to join a call  Required permissions: - CreateCall - JoinCall 
     * Join call
     */
    async joinCallRaw(requestParameters: JoinCallOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<JoinCallResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling joinCall.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling joinCall.');
        }

        if (requestParameters.joinCallRequest === null || requestParameters.joinCallRequest === undefined) {
            throw new runtime.RequiredError('joinCallRequest','Required parameter requestParameters.joinCallRequest was null or undefined when calling joinCall.');
        }

        const queryParameters: any = {};

        if (requestParameters.connectionId !== undefined) {
            queryParameters['connection_id'] = requestParameters.connectionId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/join`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.joinCallRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Request to join a call  Required permissions: - CreateCall - JoinCall 
     * Join call
     */
    async joinCall(requestParameters: JoinCallOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<JoinCallResponse> {
        const response = await this.joinCallRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all available devices 
     * List devices
     */
    async listDevicesRaw(requestParameters: ListDevicesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListDevicesResponse>> {
        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/devices`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns all available devices 
     * List devices
     */
    async listDevices(requestParameters: ListDevicesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListDevicesResponse> {
        const response = await this.listDevicesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists recordings  Required permissions: - ListRecordings 
     * List recordings (type, id)
     */
    async listRecordingsTypeId0Raw(requestParameters: ListRecordingsTypeId0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListRecordingsResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling listRecordingsTypeId0.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling listRecordingsTypeId0.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/recordings`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Lists recordings  Required permissions: - ListRecordings 
     * List recordings (type, id)
     */
    async listRecordingsTypeId0(requestParameters: ListRecordingsTypeId0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListRecordingsResponse> {
        const response = await this.listRecordingsTypeId0Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists recordings  Required permissions: - ListRecordings 
     * List recordings (type, id, session)
     */
    async listRecordingsTypeIdSession1Raw(requestParameters: ListRecordingsTypeIdSession1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListRecordingsResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling listRecordingsTypeIdSession1.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling listRecordingsTypeIdSession1.');
        }

        if (requestParameters.session === null || requestParameters.session === undefined) {
            throw new runtime.RequiredError('session','Required parameter requestParameters.session was null or undefined when calling listRecordingsTypeIdSession1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/{session}/recordings`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"session"}}`, encodeURIComponent(String(requestParameters.session))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Lists recordings  Required permissions: - ListRecordings 
     * List recordings (type, id, session)
     */
    async listRecordingsTypeIdSession1(requestParameters: ListRecordingsTypeIdSession1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListRecordingsResponse> {
        const response = await this.listRecordingsTypeIdSession1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mutes users in a call  Required permissions: - MuteUsers 
     * Mute users
     */
    async muteUsersRaw(requestParameters: MuteUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MuteUsersResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling muteUsers.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling muteUsers.');
        }

        if (requestParameters.muteUsersRequest === null || requestParameters.muteUsersRequest === undefined) {
            throw new runtime.RequiredError('muteUsersRequest','Required parameter requestParameters.muteUsersRequest was null or undefined when calling muteUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/mute_users`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.muteUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Mutes users in a call  Required permissions: - MuteUsers 
     * Mute users
     */
    async muteUsers(requestParameters: MuteUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MuteUsersResponse> {
        const response = await this.muteUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Query calls with filter query  Required permissions: - ReadCall 
     * Query call
     */
    async queryCallsRaw(requestParameters: QueryCallsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryCallsResponse>> {
        if (requestParameters.queryCallsRequest === null || requestParameters.queryCallsRequest === undefined) {
            throw new runtime.RequiredError('queryCallsRequest','Required parameter requestParameters.queryCallsRequest was null or undefined when calling queryCalls.');
        }

        const queryParameters: any = {};

        if (requestParameters.connectionId !== undefined) {
            queryParameters['connection_id'] = requestParameters.connectionId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/calls`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.queryCallsRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Query calls with filter query  Required permissions: - ReadCall 
     * Query call
     */
    async queryCalls(requestParameters: QueryCallsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryCallsResponse> {
        const response = await this.queryCallsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Query call members with filter query  Required permissions: - ReadCall 
     * Query call members
     */
    async queryMembersRaw(requestParameters: QueryMembersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryMembersResponse>> {
        if (requestParameters.queryMembersRequest === null || requestParameters.queryMembersRequest === undefined) {
            throw new runtime.RequiredError('queryMembersRequest','Required parameter requestParameters.queryMembersRequest was null or undefined when calling queryMembers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/members`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.queryMembersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Query call members with filter query  Required permissions: - ReadCall 
     * Query call members
     */
    async queryMembers(requestParameters: QueryMembersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryMembersResponse> {
        const response = await this.queryMembersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *   Sends events: - call.rejected  Required permissions: - JoinCall 
     * Reject Call
     */
    async rejectCallRaw(requestParameters: RejectCallRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RejectCallResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling rejectCall.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling rejectCall.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/reject`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *   Sends events: - call.rejected  Required permissions: - JoinCall 
     * Reject Call
     */
    async rejectCall(requestParameters: RejectCallRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RejectCallResponse> {
        const response = await this.rejectCallRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Request permission to perform an action  Sends events: - call.permission_request 
     * Request permission
     */
    async requestPermissionRaw(requestParameters: RequestPermissionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RequestPermissionResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling requestPermission.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling requestPermission.');
        }

        if (requestParameters.requestPermissionRequest === null || requestParameters.requestPermissionRequest === undefined) {
            throw new runtime.RequiredError('requestPermissionRequest','Required parameter requestParameters.requestPermissionRequest was null or undefined when calling requestPermission.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/request_permission`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.requestPermissionRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Request permission to perform an action  Sends events: - call.permission_request 
     * Request permission
     */
    async requestPermission(requestParameters: RequestPermissionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RequestPermissionResponse> {
        const response = await this.requestPermissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sends custom event to the call  Sends events: - custom  Required permissions: - SendEvent 
     * Send custom event
     */
    async sendEventRaw(requestParameters: SendEventOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SendEventResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling sendEvent.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sendEvent.');
        }

        if (requestParameters.sendEventRequest === null || requestParameters.sendEventRequest === undefined) {
            throw new runtime.RequiredError('sendEventRequest','Required parameter requestParameters.sendEventRequest was null or undefined when calling sendEvent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/event`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.sendEventRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sends custom event to the call  Sends events: - custom  Required permissions: - SendEvent 
     * Send custom event
     */
    async sendEvent(requestParameters: SendEventOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SendEventResponse> {
        const response = await this.sendEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sends reaction to the call  Sends events: - call.reaction_new  Required permissions: - CreateCallReaction 
     * Send reaction to the call
     */
    async sendVideoReactionRaw(requestParameters: SendVideoReactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SendReactionResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling sendVideoReaction.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sendVideoReaction.');
        }

        if (requestParameters.sendReactionRequest === null || requestParameters.sendReactionRequest === undefined) {
            throw new runtime.RequiredError('sendReactionRequest','Required parameter requestParameters.sendReactionRequest was null or undefined when calling sendVideoReaction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/reaction`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.sendReactionRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sends reaction to the call  Sends events: - call.reaction_new  Required permissions: - CreateCallReaction 
     * Send reaction to the call
     */
    async sendVideoReaction(requestParameters: SendVideoReactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SendReactionResponse> {
        const response = await this.sendVideoReactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Starts HLS broadcasting  Required permissions: - StartBroadcasting 
     * Start HLS broadcasting
     */
    async startHLSBroadcastingRaw(requestParameters: StartHLSBroadcastingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StartHLSBroadcastingResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling startHLSBroadcasting.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling startHLSBroadcasting.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/start_broadcasting`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Starts HLS broadcasting  Required permissions: - StartBroadcasting 
     * Start HLS broadcasting
     */
    async startHLSBroadcasting(requestParameters: StartHLSBroadcastingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StartHLSBroadcastingResponse> {
        const response = await this.startHLSBroadcastingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Starts recording  Sends events: - call.recording_started  Required permissions: - StopRecording 
     * Start recording
     */
    async startRecordingRaw(requestParameters: StartRecordingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StartRecordingResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling startRecording.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling startRecording.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/start_recording`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Starts recording  Sends events: - call.recording_started  Required permissions: - StopRecording 
     * Start recording
     */
    async startRecording(requestParameters: StartRecordingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StartRecordingResponse> {
        const response = await this.startRecordingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Starts transcription  Required permissions: - StartTranscription 
     * Start transcription
     */
    async startTranscriptionRaw(requestParameters: StartTranscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StartTranscriptionResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling startTranscription.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling startTranscription.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/start_transcription`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Starts transcription  Required permissions: - StartTranscription 
     * Start transcription
     */
    async startTranscription(requestParameters: StartTranscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StartTranscriptionResponse> {
        const response = await this.startTranscriptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stops HLS broadcasting  Required permissions: - StopBroadcasting 
     * Stop HLS broadcasting
     */
    async stopHLSBroadcastingRaw(requestParameters: StopHLSBroadcastingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StopHLSBroadcastingResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling stopHLSBroadcasting.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling stopHLSBroadcasting.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/stop_broadcasting`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Stops HLS broadcasting  Required permissions: - StopBroadcasting 
     * Stop HLS broadcasting
     */
    async stopHLSBroadcasting(requestParameters: StopHLSBroadcastingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StopHLSBroadcastingResponse> {
        const response = await this.stopHLSBroadcastingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *   Sends events: - call.updated  Required permissions: - UpdateCall 
     * Set call as not live
     */
    async stopLiveRaw(requestParameters: StopLiveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StopLiveResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling stopLive.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling stopLive.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/stop_live`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *   Sends events: - call.updated  Required permissions: - UpdateCall 
     * Set call as not live
     */
    async stopLive(requestParameters: StopLiveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StopLiveResponse> {
        const response = await this.stopLiveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stops recording  Sends events: - call.recording_stopped  Required permissions: - StopRecording 
     * Stop recording
     */
    async stopRecordingRaw(requestParameters: StopRecordingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StopRecordingResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling stopRecording.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling stopRecording.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/stop_recording`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Stops recording  Sends events: - call.recording_stopped  Required permissions: - StopRecording 
     * Stop recording
     */
    async stopRecording(requestParameters: StopRecordingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StopRecordingResponse> {
        const response = await this.stopRecordingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stops transcription  Required permissions: - StopTranscription 
     * Stop transcription
     */
    async stopTranscriptionRaw(requestParameters: StopTranscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StopTranscriptionResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling stopTranscription.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling stopTranscription.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/stop_transcription`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Stops transcription  Required permissions: - StopTranscription 
     * Stop transcription
     */
    async stopTranscription(requestParameters: StopTranscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StopTranscriptionResponse> {
        const response = await this.stopTranscriptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Removes the block for a user on a call. The user will be able to join the call again.  Sends events: - call.unblocked_user  Required permissions: - BlockUser 
     * Unblocks user on a call
     */
    async unblockUserRaw(requestParameters: UnblockUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UnblockUserResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling unblockUser.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling unblockUser.');
        }

        if (requestParameters.unblockUserRequest === null || requestParameters.unblockUserRequest === undefined) {
            throw new runtime.RequiredError('unblockUserRequest','Required parameter requestParameters.unblockUserRequest was null or undefined when calling unblockUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/unblock`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.unblockUserRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Removes the block for a user on a call. The user will be able to join the call again.  Sends events: - call.unblocked_user  Required permissions: - BlockUser 
     * Unblocks user on a call
     */
    async unblockUser(requestParameters: UnblockUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UnblockUserResponse> {
        const response = await this.unblockUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *   Sends events: - call.updated  Required permissions: - UpdateCall 
     * Update Call
     */
    async updateCallRaw(requestParameters: UpdateCallOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateCallResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling updateCall.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateCall.');
        }

        if (requestParameters.updateCallRequest === null || requestParameters.updateCallRequest === undefined) {
            throw new runtime.RequiredError('updateCallRequest','Required parameter requestParameters.updateCallRequest was null or undefined when calling updateCall.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateCallRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *   Sends events: - call.updated  Required permissions: - UpdateCall 
     * Update Call
     */
    async updateCall(requestParameters: UpdateCallOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateCallResponse> {
        const response = await this.updateCallRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *   Sends events: - call.member_added - call.member_removed - call.member_updated  Required permissions: - RemoveCallMember - UpdateCallMember - UpdateCallMemberRole 
     * Update Call Member
     */
    async updateCallMembersRaw(requestParameters: UpdateCallMembersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateCallMembersResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling updateCallMembers.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateCallMembers.');
        }

        if (requestParameters.updateCallMembersRequest === null || requestParameters.updateCallMembersRequest === undefined) {
            throw new runtime.RequiredError('updateCallMembersRequest','Required parameter requestParameters.updateCallMembersRequest was null or undefined when calling updateCallMembers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/members`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateCallMembersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *   Sends events: - call.member_added - call.member_removed - call.member_updated  Required permissions: - RemoveCallMember - UpdateCallMember - UpdateCallMemberRole 
     * Update Call Member
     */
    async updateCallMembers(requestParameters: UpdateCallMembersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateCallMembersResponse> {
        const response = await this.updateCallMembersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates user permissions  Sends events: - call.permissions_updated  Required permissions: - UpdateCallPermissions 
     * Update user permissions
     */
    async updateUserPermissionsRaw(requestParameters: UpdateUserPermissionsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateUserPermissionsResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling updateUserPermissions.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateUserPermissions.');
        }

        if (requestParameters.updateUserPermissionsRequest === null || requestParameters.updateUserPermissionsRequest === undefined) {
            throw new runtime.RequiredError('updateUserPermissionsRequest','Required parameter requestParameters.updateUserPermissionsRequest was null or undefined when calling updateUserPermissions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/user_permissions`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateUserPermissionsRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates user permissions  Sends events: - call.permissions_updated  Required permissions: - UpdateCallPermissions 
     * Update user permissions
     */
    async updateUserPermissions(requestParameters: UpdateUserPermissionsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateUserPermissionsResponse> {
        const response = await this.updateUserPermissionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Establishes WebSocket connection for user to video  Sends events: - connection.ok - health.check 
     * Video Connect (WebSocket)
     */
    async videoConnectRaw(requestParameters: VideoConnectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.wSAuthMessageRequest === null || requestParameters.wSAuthMessageRequest === undefined) {
            throw new runtime.RequiredError('wSAuthMessageRequest','Required parameter requestParameters.wSAuthMessageRequest was null or undefined when calling videoConnect.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/video/connect`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.wSAuthMessageRequest,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Establishes WebSocket connection for user to video  Sends events: - connection.ok - health.check 
     * Video Connect (WebSocket)
     */
    async videoConnect(requestParameters: VideoConnectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.videoConnectRaw(requestParameters, initOverrides);
    }

    /**
     * Pins a track for all users in the call.  Required permissions: - PinCallTrack 
     * Pin
     */
    async videoPinRaw(requestParameters: VideoPinRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PinResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling videoPin.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling videoPin.');
        }

        if (requestParameters.pinRequest === null || requestParameters.pinRequest === undefined) {
            throw new runtime.RequiredError('pinRequest','Required parameter requestParameters.pinRequest was null or undefined when calling videoPin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/pin`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.pinRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Pins a track for all users in the call.  Required permissions: - PinCallTrack 
     * Pin
     */
    async videoPin(requestParameters: VideoPinRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PinResponse> {
        const response = await this.videoPinRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unpins a track for all users in the call.  Required permissions: - PinCallTrack 
     * Unpin
     */
    async videoUnpinRaw(requestParameters: VideoUnpinRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UnpinResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling videoUnpin.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling videoUnpin.');
        }

        if (requestParameters.unpinRequest === null || requestParameters.unpinRequest === undefined) {
            throw new runtime.RequiredError('unpinRequest','Required parameter requestParameters.unpinRequest was null or undefined when calling videoUnpin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/call/{type}/{id}/unpin`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.unpinRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Unpins a track for all users in the call.  Required permissions: - PinCallTrack 
     * Unpin
     */
    async videoUnpin(requestParameters: VideoUnpinRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UnpinResponse> {
        const response = await this.videoUnpinRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
