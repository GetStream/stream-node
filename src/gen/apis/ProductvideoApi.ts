/* tslint:disable */
/* eslint-disable */
/**
 * Stream API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v113.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  APIError,
  BlockUserRequest,
  BlockUserResponse,
  CollectUserFeedbackRequest,
  CollectUserFeedbackResponse,
  CreateCallTypeRequest,
  CreateCallTypeResponse,
  DeleteRecordingResponse,
  DeleteTranscriptionResponse,
  EndCallResponse,
  GetCallResponse,
  GetCallStatsResponse,
  GetCallTypeResponse,
  GetEdgesResponse,
  GetOrCreateCallRequest,
  GetOrCreateCallResponse,
  GoLiveRequest,
  GoLiveResponse,
  ListCallTypeResponse,
  ListRecordingsResponse,
  ListTranscriptionsResponse,
  MuteUsersRequest,
  MuteUsersResponse,
  PinRequest,
  PinResponse,
  QueryCallMembersRequest,
  QueryCallMembersResponse,
  QueryCallStatsRequest,
  QueryCallStatsResponse,
  QueryCallsRequest,
  QueryCallsResponse,
  Response,
  SendCallEventRequest,
  SendCallEventResponse,
  StartHLSBroadcastingResponse,
  StartRecordingRequest,
  StartRecordingResponse,
  StartTranscriptionRequest,
  StartTranscriptionResponse,
  StopHLSBroadcastingResponse,
  StopLiveResponse,
  StopRecordingResponse,
  StopTranscriptionResponse,
  UnblockUserRequest,
  UnblockUserResponse,
  UnpinRequest,
  UnpinResponse,
  UpdateCallMembersRequest,
  UpdateCallMembersResponse,
  UpdateCallRequest,
  UpdateCallResponse,
  UpdateCallTypeRequest,
  UpdateCallTypeResponse,
  UpdateUserPermissionsRequest,
  UpdateUserPermissionsResponse,
} from '../models';

export interface BlockUserOperationRequest {
    type: string;
    id: string;
    blockUserRequest: BlockUserRequest | null;
}

export interface CollectUserFeedbackOperationRequest {
    type: string;
    id: string;
    session: string;
    collectUserFeedbackRequest: CollectUserFeedbackRequest | null;
}

export interface CreateCallTypeOperationRequest {
    createCallTypeRequest: CreateCallTypeRequest | null;
}

export interface DeleteCallTypeRequest {
    name: string;
}

export interface DeleteRecordingRequest {
    type: string;
    id: string;
    session: string;
    filename: string;
}

export interface DeleteTranscriptionRequest {
    type: string;
    id: string;
    session: string;
    filename: string;
}

export interface EndCallRequest {
    type: string;
    id: string;
}

export interface GetCallRequest {
    type: string;
    id: string;
    membersLimit?: number;
    ring?: boolean;
    notify?: boolean;
}

export interface GetCallStatsRequest {
    type: string;
    id: string;
    session: string;
}

export interface GetCallTypeRequest {
    name: string;
}

export interface GetOrCreateCallOperationRequest {
    type: string;
    id: string;
    getOrCreateCallRequest: GetOrCreateCallRequest | null;
}

export interface GoLiveOperationRequest {
    type: string;
    id: string;
    goLiveRequest: GoLiveRequest | null;
}

export interface ListRecordingsRequest {
    type: string;
    id: string;
}

export interface ListTranscriptionsRequest {
    type: string;
    id: string;
}

export interface MuteUsersOperationRequest {
    type: string;
    id: string;
    muteUsersRequest: MuteUsersRequest | null;
}

export interface QueryCallMembersOperationRequest {
    queryCallMembersRequest: QueryCallMembersRequest | null;
}

export interface QueryCallStatsOperationRequest {
    queryCallStatsRequest: QueryCallStatsRequest | null;
}

export interface QueryCallsOperationRequest {
    queryCallsRequest: QueryCallsRequest | null;
}

export interface SendCallEventOperationRequest {
    type: string;
    id: string;
    sendCallEventRequest: SendCallEventRequest | null;
}

export interface StartHLSBroadcastingRequest {
    type: string;
    id: string;
}

export interface StartRecordingOperationRequest {
    type: string;
    id: string;
    startRecordingRequest: StartRecordingRequest | null;
}

export interface StartTranscriptionOperationRequest {
    type: string;
    id: string;
    startTranscriptionRequest: StartTranscriptionRequest | null;
}

export interface StopHLSBroadcastingRequest {
    type: string;
    id: string;
}

export interface StopLiveRequest {
    type: string;
    id: string;
}

export interface StopRecordingRequest {
    type: string;
    id: string;
}

export interface StopTranscriptionRequest {
    type: string;
    id: string;
}

export interface UnblockUserOperationRequest {
    type: string;
    id: string;
    unblockUserRequest: UnblockUserRequest | null;
}

export interface UpdateCallOperationRequest {
    type: string;
    id: string;
    updateCallRequest: UpdateCallRequest | null;
}

export interface UpdateCallMembersOperationRequest {
    type: string;
    id: string;
    updateCallMembersRequest: UpdateCallMembersRequest | null;
}

export interface UpdateCallTypeOperationRequest {
    name: string;
    updateCallTypeRequest: UpdateCallTypeRequest | null;
}

export interface UpdateUserPermissionsOperationRequest {
    type: string;
    id: string;
    updateUserPermissionsRequest: UpdateUserPermissionsRequest | null;
}

export interface VideoPinRequest {
    type: string;
    id: string;
    pinRequest: PinRequest | null;
}

export interface VideoUnpinRequest {
    type: string;
    id: string;
    unpinRequest: UnpinRequest | null;
}

/**
 * 
 */
export class ProductvideoApi extends runtime.BaseAPI {

    /**
     * Block a user, preventing them from joining the call until they are unblocked.  Sends events: - call.blocked_user  Required permissions: - BlockUser 
     * Block user on a call
     */
    async blockUserRaw(requestParameters: BlockUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockUserResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling blockUser.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling blockUser.');
        }

        if (requestParameters.blockUserRequest === null || requestParameters.blockUserRequest === undefined) {
            throw new runtime.RequiredError('blockUserRequest','Required parameter requestParameters.blockUserRequest was null or undefined when calling blockUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/block`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.blockUserRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Block a user, preventing them from joining the call until they are unblocked.  Sends events: - call.blocked_user  Required permissions: - BlockUser 
     * Block user on a call
     */
    async blockUser(requestParameters: BlockUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockUserResponse> {
        const response = await this.blockUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *   Required permissions: - JoinCall 
     * Collect user feedback
     */
    async collectUserFeedbackRaw(requestParameters: CollectUserFeedbackOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CollectUserFeedbackResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling collectUserFeedback.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling collectUserFeedback.');
        }

        if (requestParameters.session === null || requestParameters.session === undefined) {
            throw new runtime.RequiredError('session','Required parameter requestParameters.session was null or undefined when calling collectUserFeedback.');
        }

        if (requestParameters.collectUserFeedbackRequest === null || requestParameters.collectUserFeedbackRequest === undefined) {
            throw new runtime.RequiredError('collectUserFeedbackRequest','Required parameter requestParameters.collectUserFeedbackRequest was null or undefined when calling collectUserFeedback.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/feedback/{session}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"session"}}`, encodeURIComponent(String(requestParameters.session))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.collectUserFeedbackRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *   Required permissions: - JoinCall 
     * Collect user feedback
     */
    async collectUserFeedback(requestParameters: CollectUserFeedbackOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CollectUserFeedbackResponse> {
        const response = await this.collectUserFeedbackRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  
     * Create Call Type
     */
    async createCallTypeRaw(requestParameters: CreateCallTypeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateCallTypeResponse>> {
        if (requestParameters.createCallTypeRequest === null || requestParameters.createCallTypeRequest === undefined) {
            throw new runtime.RequiredError('createCallTypeRequest','Required parameter requestParameters.createCallTypeRequest was null or undefined when calling createCallType.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/calltypes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createCallTypeRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *  
     * Create Call Type
     */
    async createCallType(requestParameters: CreateCallTypeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateCallTypeResponse> {
        const response = await this.createCallTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  
     * Delete Call Type
     */
    async deleteCallTypeRaw(requestParameters: DeleteCallTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCallType.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/calltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *  
     * Delete Call Type
     */
    async deleteCallType(requestParameters: DeleteCallTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.deleteCallTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes recording  Required permissions: - DeleteRecording 
     * Delete recording
     */
    async deleteRecordingRaw(requestParameters: DeleteRecordingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteRecordingResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling deleteRecording.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteRecording.');
        }

        if (requestParameters.session === null || requestParameters.session === undefined) {
            throw new runtime.RequiredError('session','Required parameter requestParameters.session was null or undefined when calling deleteRecording.');
        }

        if (requestParameters.filename === null || requestParameters.filename === undefined) {
            throw new runtime.RequiredError('filename','Required parameter requestParameters.filename was null or undefined when calling deleteRecording.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/{session}/recordings/{filename}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"session"}}`, encodeURIComponent(String(requestParameters.session))).replace(`{${"filename"}}`, encodeURIComponent(String(requestParameters.filename))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes recording  Required permissions: - DeleteRecording 
     * Delete recording
     */
    async deleteRecording(requestParameters: DeleteRecordingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteRecordingResponse> {
        const response = await this.deleteRecordingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes transcription  Required permissions: - DeleteTranscription 
     * Delete transcription
     */
    async deleteTranscriptionRaw(requestParameters: DeleteTranscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteTranscriptionResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling deleteTranscription.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteTranscription.');
        }

        if (requestParameters.session === null || requestParameters.session === undefined) {
            throw new runtime.RequiredError('session','Required parameter requestParameters.session was null or undefined when calling deleteTranscription.');
        }

        if (requestParameters.filename === null || requestParameters.filename === undefined) {
            throw new runtime.RequiredError('filename','Required parameter requestParameters.filename was null or undefined when calling deleteTranscription.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/{session}/transcriptions/{filename}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"session"}}`, encodeURIComponent(String(requestParameters.session))).replace(`{${"filename"}}`, encodeURIComponent(String(requestParameters.filename))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes transcription  Required permissions: - DeleteTranscription 
     * Delete transcription
     */
    async deleteTranscription(requestParameters: DeleteTranscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteTranscriptionResponse> {
        const response = await this.deleteTranscriptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *   Sends events: - call.ended  Required permissions: - EndCall 
     * End call
     */
    async endCallRaw(requestParameters: EndCallRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EndCallResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling endCall.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling endCall.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/mark_ended`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *   Sends events: - call.ended  Required permissions: - EndCall 
     * End call
     */
    async endCall(requestParameters: EndCallRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EndCallResponse> {
        const response = await this.endCallRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *   Required permissions: - ReadCall 
     * Get Call
     */
    async getCallRaw(requestParameters: GetCallRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCallResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling getCall.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getCall.');
        }

        const queryParameters: any = {};

        if (requestParameters.membersLimit !== undefined) {
            queryParameters['members_limit'] = requestParameters.membersLimit;
        }

        if (requestParameters.ring !== undefined) {
            queryParameters['ring'] = requestParameters.ring;
        }

        if (requestParameters.notify !== undefined) {
            queryParameters['notify'] = requestParameters.notify;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *   Required permissions: - ReadCall 
     * Get Call
     */
    async getCall(requestParameters: GetCallRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCallResponse> {
        const response = await this.getCallRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *   Required permissions: - ReadCallStats 
     * Get Call Stats
     */
    async getCallStatsRaw(requestParameters: GetCallStatsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCallStatsResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling getCallStats.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getCallStats.');
        }

        if (requestParameters.session === null || requestParameters.session === undefined) {
            throw new runtime.RequiredError('session','Required parameter requestParameters.session was null or undefined when calling getCallStats.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/stats/{session}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"session"}}`, encodeURIComponent(String(requestParameters.session))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *   Required permissions: - ReadCallStats 
     * Get Call Stats
     */
    async getCallStats(requestParameters: GetCallStatsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCallStatsResponse> {
        const response = await this.getCallStatsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  
     * Get Call Type
     */
    async getCallTypeRaw(requestParameters: GetCallTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCallTypeResponse>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getCallType.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/calltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *  
     * Get Call Type
     */
    async getCallType(requestParameters: GetCallTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCallTypeResponse> {
        const response = await this.getCallTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the list of all edges available for video calls. 
     * Get Edges
     */
    async getEdgesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetEdgesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/edges`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the list of all edges available for video calls. 
     * Get Edges
     */
    async getEdges(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetEdgesResponse> {
        const response = await this.getEdgesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Gets or creates a new call  Sends events: - call.created - call.notification - call.ring  Required permissions: - CreateCall - ReadCall - UpdateCallSettings 
     * Get or create a call
     */
    async getOrCreateCallRaw(requestParameters: GetOrCreateCallOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetOrCreateCallResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling getOrCreateCall.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getOrCreateCall.');
        }

        if (requestParameters.getOrCreateCallRequest === null || requestParameters.getOrCreateCallRequest === undefined) {
            throw new runtime.RequiredError('getOrCreateCallRequest','Required parameter requestParameters.getOrCreateCallRequest was null or undefined when calling getOrCreateCall.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.getOrCreateCallRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets or creates a new call  Sends events: - call.created - call.notification - call.ring  Required permissions: - CreateCall - ReadCall - UpdateCallSettings 
     * Get or create a call
     */
    async getOrCreateCall(requestParameters: GetOrCreateCallOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetOrCreateCallResponse> {
        const response = await this.getOrCreateCallRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *   Sends events: - call.live_started  Required permissions: - UpdateCall 
     * Set call as live
     */
    async goLiveRaw(requestParameters: GoLiveOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GoLiveResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling goLive.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling goLive.');
        }

        if (requestParameters.goLiveRequest === null || requestParameters.goLiveRequest === undefined) {
            throw new runtime.RequiredError('goLiveRequest','Required parameter requestParameters.goLiveRequest was null or undefined when calling goLive.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/go_live`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.goLiveRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *   Sends events: - call.live_started  Required permissions: - UpdateCall 
     * Set call as live
     */
    async goLive(requestParameters: GoLiveOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GoLiveResponse> {
        const response = await this.goLiveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  
     * List Call Type
     */
    async listCallTypesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListCallTypeResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/calltypes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *  
     * List Call Type
     */
    async listCallTypes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListCallTypeResponse> {
        const response = await this.listCallTypesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Lists recordings  Required permissions: - ListRecordings 
     * List recordings
     */
    async listRecordingsRaw(requestParameters: ListRecordingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListRecordingsResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling listRecordings.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling listRecordings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/recordings`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Lists recordings  Required permissions: - ListRecordings 
     * List recordings
     */
    async listRecordings(requestParameters: ListRecordingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListRecordingsResponse> {
        const response = await this.listRecordingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists transcriptions  Required permissions: - ListTranscriptions 
     * List transcriptions
     */
    async listTranscriptionsRaw(requestParameters: ListTranscriptionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListTranscriptionsResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling listTranscriptions.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling listTranscriptions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/transcriptions`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Lists transcriptions  Required permissions: - ListTranscriptions 
     * List transcriptions
     */
    async listTranscriptions(requestParameters: ListTranscriptionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListTranscriptionsResponse> {
        const response = await this.listTranscriptionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mutes users in a call  Required permissions: - MuteUsers 
     * Mute users
     */
    async muteUsersRaw(requestParameters: MuteUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MuteUsersResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling muteUsers.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling muteUsers.');
        }

        if (requestParameters.muteUsersRequest === null || requestParameters.muteUsersRequest === undefined) {
            throw new runtime.RequiredError('muteUsersRequest','Required parameter requestParameters.muteUsersRequest was null or undefined when calling muteUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/mute_users`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.muteUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Mutes users in a call  Required permissions: - MuteUsers 
     * Mute users
     */
    async muteUsers(requestParameters: MuteUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MuteUsersResponse> {
        const response = await this.muteUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Query call members with filter query  Required permissions: - ReadCall 
     * Query call members
     */
    async queryCallMembersRaw(requestParameters: QueryCallMembersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryCallMembersResponse>> {
        if (requestParameters.queryCallMembersRequest === null || requestParameters.queryCallMembersRequest === undefined) {
            throw new runtime.RequiredError('queryCallMembersRequest','Required parameter requestParameters.queryCallMembersRequest was null or undefined when calling queryCallMembers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/members`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.queryCallMembersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Query call members with filter query  Required permissions: - ReadCall 
     * Query call members
     */
    async queryCallMembers(requestParameters: QueryCallMembersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryCallMembersResponse> {
        const response = await this.queryCallMembersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *   Required permissions: - ReadCallStats 
     * Query Call Stats
     */
    async queryCallStatsRaw(requestParameters: QueryCallStatsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryCallStatsResponse>> {
        if (requestParameters.queryCallStatsRequest === null || requestParameters.queryCallStatsRequest === undefined) {
            throw new runtime.RequiredError('queryCallStatsRequest','Required parameter requestParameters.queryCallStatsRequest was null or undefined when calling queryCallStats.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/stats`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.queryCallStatsRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *   Required permissions: - ReadCallStats 
     * Query Call Stats
     */
    async queryCallStats(requestParameters: QueryCallStatsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryCallStatsResponse> {
        const response = await this.queryCallStatsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Query calls with filter query  Required permissions: - ReadCall 
     * Query call
     */
    async queryCallsRaw(requestParameters: QueryCallsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryCallsResponse>> {
        if (requestParameters.queryCallsRequest === null || requestParameters.queryCallsRequest === undefined) {
            throw new runtime.RequiredError('queryCallsRequest','Required parameter requestParameters.queryCallsRequest was null or undefined when calling queryCalls.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/calls`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.queryCallsRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Query calls with filter query  Required permissions: - ReadCall 
     * Query call
     */
    async queryCalls(requestParameters: QueryCallsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryCallsResponse> {
        const response = await this.queryCallsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sends custom event to the call  Sends events: - custom  Required permissions: - SendEvent 
     * Send custom event
     */
    async sendCallEventRaw(requestParameters: SendCallEventOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SendCallEventResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling sendCallEvent.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sendCallEvent.');
        }

        if (requestParameters.sendCallEventRequest === null || requestParameters.sendCallEventRequest === undefined) {
            throw new runtime.RequiredError('sendCallEventRequest','Required parameter requestParameters.sendCallEventRequest was null or undefined when calling sendCallEvent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/event`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.sendCallEventRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sends custom event to the call  Sends events: - custom  Required permissions: - SendEvent 
     * Send custom event
     */
    async sendCallEvent(requestParameters: SendCallEventOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SendCallEventResponse> {
        const response = await this.sendCallEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Starts HLS broadcasting  Required permissions: - StartBroadcasting 
     * Start HLS broadcasting
     */
    async startHLSBroadcastingRaw(requestParameters: StartHLSBroadcastingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StartHLSBroadcastingResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling startHLSBroadcasting.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling startHLSBroadcasting.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/start_broadcasting`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Starts HLS broadcasting  Required permissions: - StartBroadcasting 
     * Start HLS broadcasting
     */
    async startHLSBroadcasting(requestParameters: StartHLSBroadcastingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StartHLSBroadcastingResponse> {
        const response = await this.startHLSBroadcastingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Starts recording  Sends events: - call.recording_started  Required permissions: - StartRecording 
     * Start recording
     */
    async startRecordingRaw(requestParameters: StartRecordingOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StartRecordingResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling startRecording.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling startRecording.');
        }

        if (requestParameters.startRecordingRequest === null || requestParameters.startRecordingRequest === undefined) {
            throw new runtime.RequiredError('startRecordingRequest','Required parameter requestParameters.startRecordingRequest was null or undefined when calling startRecording.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/start_recording`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.startRecordingRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Starts recording  Sends events: - call.recording_started  Required permissions: - StartRecording 
     * Start recording
     */
    async startRecording(requestParameters: StartRecordingOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StartRecordingResponse> {
        const response = await this.startRecordingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Starts transcription  Required permissions: - StartTranscription 
     * Start transcription
     */
    async startTranscriptionRaw(requestParameters: StartTranscriptionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StartTranscriptionResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling startTranscription.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling startTranscription.');
        }

        if (requestParameters.startTranscriptionRequest === null || requestParameters.startTranscriptionRequest === undefined) {
            throw new runtime.RequiredError('startTranscriptionRequest','Required parameter requestParameters.startTranscriptionRequest was null or undefined when calling startTranscription.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/start_transcription`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.startTranscriptionRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Starts transcription  Required permissions: - StartTranscription 
     * Start transcription
     */
    async startTranscription(requestParameters: StartTranscriptionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StartTranscriptionResponse> {
        const response = await this.startTranscriptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stops HLS broadcasting  Required permissions: - StopBroadcasting 
     * Stop HLS broadcasting
     */
    async stopHLSBroadcastingRaw(requestParameters: StopHLSBroadcastingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StopHLSBroadcastingResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling stopHLSBroadcasting.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling stopHLSBroadcasting.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/stop_broadcasting`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Stops HLS broadcasting  Required permissions: - StopBroadcasting 
     * Stop HLS broadcasting
     */
    async stopHLSBroadcasting(requestParameters: StopHLSBroadcastingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StopHLSBroadcastingResponse> {
        const response = await this.stopHLSBroadcastingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *   Sends events: - call.updated  Required permissions: - UpdateCall 
     * Set call as not live
     */
    async stopLiveRaw(requestParameters: StopLiveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StopLiveResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling stopLive.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling stopLive.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/stop_live`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *   Sends events: - call.updated  Required permissions: - UpdateCall 
     * Set call as not live
     */
    async stopLive(requestParameters: StopLiveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StopLiveResponse> {
        const response = await this.stopLiveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stops recording  Sends events: - call.recording_stopped  Required permissions: - StopRecording 
     * Stop recording
     */
    async stopRecordingRaw(requestParameters: StopRecordingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StopRecordingResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling stopRecording.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling stopRecording.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/stop_recording`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Stops recording  Sends events: - call.recording_stopped  Required permissions: - StopRecording 
     * Stop recording
     */
    async stopRecording(requestParameters: StopRecordingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StopRecordingResponse> {
        const response = await this.stopRecordingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stops transcription  Sends events: - call.transcription_stopped  Required permissions: - StopTranscription 
     * Stop transcription
     */
    async stopTranscriptionRaw(requestParameters: StopTranscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StopTranscriptionResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling stopTranscription.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling stopTranscription.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/stop_transcription`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Stops transcription  Sends events: - call.transcription_stopped  Required permissions: - StopTranscription 
     * Stop transcription
     */
    async stopTranscription(requestParameters: StopTranscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StopTranscriptionResponse> {
        const response = await this.stopTranscriptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Removes the block for a user on a call. The user will be able to join the call again.  Sends events: - call.unblocked_user  Required permissions: - BlockUser 
     * Unblocks user on a call
     */
    async unblockUserRaw(requestParameters: UnblockUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UnblockUserResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling unblockUser.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling unblockUser.');
        }

        if (requestParameters.unblockUserRequest === null || requestParameters.unblockUserRequest === undefined) {
            throw new runtime.RequiredError('unblockUserRequest','Required parameter requestParameters.unblockUserRequest was null or undefined when calling unblockUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/unblock`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.unblockUserRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Removes the block for a user on a call. The user will be able to join the call again.  Sends events: - call.unblocked_user  Required permissions: - BlockUser 
     * Unblocks user on a call
     */
    async unblockUser(requestParameters: UnblockUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UnblockUserResponse> {
        const response = await this.unblockUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *   Sends events: - call.updated  Required permissions: - UpdateCall 
     * Update Call
     */
    async updateCallRaw(requestParameters: UpdateCallOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateCallResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling updateCall.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateCall.');
        }

        if (requestParameters.updateCallRequest === null || requestParameters.updateCallRequest === undefined) {
            throw new runtime.RequiredError('updateCallRequest','Required parameter requestParameters.updateCallRequest was null or undefined when calling updateCall.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateCallRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *   Sends events: - call.updated  Required permissions: - UpdateCall 
     * Update Call
     */
    async updateCall(requestParameters: UpdateCallOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateCallResponse> {
        const response = await this.updateCallRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *   Sends events: - call.member_added - call.member_removed - call.member_updated  Required permissions: - RemoveCallMember - UpdateCallMember - UpdateCallMemberRole 
     * Update Call Member
     */
    async updateCallMembersRaw(requestParameters: UpdateCallMembersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateCallMembersResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling updateCallMembers.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateCallMembers.');
        }

        if (requestParameters.updateCallMembersRequest === null || requestParameters.updateCallMembersRequest === undefined) {
            throw new runtime.RequiredError('updateCallMembersRequest','Required parameter requestParameters.updateCallMembersRequest was null or undefined when calling updateCallMembers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/members`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateCallMembersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *   Sends events: - call.member_added - call.member_removed - call.member_updated  Required permissions: - RemoveCallMember - UpdateCallMember - UpdateCallMemberRole 
     * Update Call Member
     */
    async updateCallMembers(requestParameters: UpdateCallMembersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateCallMembersResponse> {
        const response = await this.updateCallMembersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  
     * Update Call Type
     */
    async updateCallTypeRaw(requestParameters: UpdateCallTypeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateCallTypeResponse>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling updateCallType.');
        }

        if (requestParameters.updateCallTypeRequest === null || requestParameters.updateCallTypeRequest === undefined) {
            throw new runtime.RequiredError('updateCallTypeRequest','Required parameter requestParameters.updateCallTypeRequest was null or undefined when calling updateCallType.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/calltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateCallTypeRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *  
     * Update Call Type
     */
    async updateCallType(requestParameters: UpdateCallTypeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateCallTypeResponse> {
        const response = await this.updateCallTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates user permissions  Sends events: - call.permissions_updated  Required permissions: - UpdateCallPermissions 
     * Update user permissions
     */
    async updateUserPermissionsRaw(requestParameters: UpdateUserPermissionsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateUserPermissionsResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling updateUserPermissions.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateUserPermissions.');
        }

        if (requestParameters.updateUserPermissionsRequest === null || requestParameters.updateUserPermissionsRequest === undefined) {
            throw new runtime.RequiredError('updateUserPermissionsRequest','Required parameter requestParameters.updateUserPermissionsRequest was null or undefined when calling updateUserPermissions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/user_permissions`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateUserPermissionsRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates user permissions  Sends events: - call.permissions_updated  Required permissions: - UpdateCallPermissions 
     * Update user permissions
     */
    async updateUserPermissions(requestParameters: UpdateUserPermissionsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateUserPermissionsResponse> {
        const response = await this.updateUserPermissionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Pins a track for all users in the call.  Required permissions: - PinCallTrack 
     * Pin
     */
    async videoPinRaw(requestParameters: VideoPinRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PinResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling videoPin.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling videoPin.');
        }

        if (requestParameters.pinRequest === null || requestParameters.pinRequest === undefined) {
            throw new runtime.RequiredError('pinRequest','Required parameter requestParameters.pinRequest was null or undefined when calling videoPin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/pin`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.pinRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Pins a track for all users in the call.  Required permissions: - PinCallTrack 
     * Pin
     */
    async videoPin(requestParameters: VideoPinRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PinResponse> {
        const response = await this.videoPinRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unpins a track for all users in the call.  Required permissions: - PinCallTrack 
     * Unpin
     */
    async videoUnpinRaw(requestParameters: VideoUnpinRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UnpinResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling videoUnpin.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling videoUnpin.');
        }

        if (requestParameters.unpinRequest === null || requestParameters.unpinRequest === undefined) {
            throw new runtime.RequiredError('unpinRequest','Required parameter requestParameters.unpinRequest was null or undefined when calling videoUnpin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/video/call/{type}/{id}/unpin`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.unpinRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Unpins a track for all users in the call.  Required permissions: - PinCallTrack 
     * Unpin
     */
    async videoUnpin(requestParameters: VideoUnpinRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UnpinResponse> {
        const response = await this.videoUnpinRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
