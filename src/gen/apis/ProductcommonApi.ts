/* tslint:disable */
/* eslint-disable */
/**
 * Stream API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v113.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  APIError,
  BanRequest,
  CheckExternalStorageResponse,
  CheckPushRequest,
  CheckPushResponse,
  CheckSNSRequest,
  CheckSNSResponse,
  CheckSQSRequest,
  CheckSQSResponse,
  CreateBlockListRequest,
  CreateDeviceRequest,
  CreateExternalStorageRequest,
  CreateExternalStorageResponse,
  CreateGuestRequest,
  CreateGuestResponse,
  CreateImportRequest,
  CreateImportResponse,
  CreateImportURLRequest,
  CreateImportURLResponse,
  CreateRoleRequest,
  CreateRoleResponse,
  DeactivateUserRequest,
  DeactivateUserResponse,
  DeactivateUsersRequest,
  DeactivateUsersResponse,
  DeleteExternalStorageResponse,
  DeleteUsersRequest,
  DeleteUsersResponse,
  ExportUserResponse,
  ExportUsersRequest,
  ExportUsersResponse,
  FlagRequest,
  FlagResponse,
  GetApplicationResponse,
  GetBlockListResponse,
  GetCustomPermissionResponse,
  GetImportResponse,
  GetOGResponse,
  GetRateLimitsResponse,
  GetTaskResponse,
  ListBlockListResponse,
  ListDevicesResponse,
  ListExternalStorageResponse,
  ListImportsResponse,
  ListPermissionsResponse,
  ListPushProvidersResponse,
  ListRolesResponse,
  MuteUserRequest,
  MuteUserResponse,
  QueryUsersPayload,
  QueryUsersResponse,
  ReactivateUserRequest,
  ReactivateUserResponse,
  ReactivateUsersRequest,
  ReactivateUsersResponse,
  Response,
  RestoreUsersRequest,
  UnmuteResponse,
  UnmuteUserRequest,
  UpdateAppRequest,
  UpdateBlockListRequest,
  UpdateExternalStorageRequest,
  UpdateExternalStorageResponse,
  UpdateUsersPartialRequest,
  UpdateUsersRequest,
  UpdateUsersResponse,
  UpsertPushProviderRequest,
  UpsertPushProviderResponse,
} from '../models';

export interface BanOperationRequest {
    banRequest: BanRequest | null;
}

export interface CheckExternalStorageRequest {
    name: string;
}

export interface CheckPushOperationRequest {
    checkPushRequest: CheckPushRequest | null;
}

export interface CheckSNSOperationRequest {
    checkSNSRequest: CheckSNSRequest | null;
}

export interface CheckSQSOperationRequest {
    checkSQSRequest: CheckSQSRequest | null;
}

export interface CreateBlockListOperationRequest {
    createBlockListRequest: CreateBlockListRequest | null;
}

export interface CreateDeviceOperationRequest {
    createDeviceRequest: CreateDeviceRequest | null;
}

export interface CreateExternalStorageOperationRequest {
    createExternalStorageRequest: CreateExternalStorageRequest | null;
}

export interface CreateGuestOperationRequest {
    createGuestRequest: CreateGuestRequest | null;
}

export interface CreateImportOperationRequest {
    createImportRequest: CreateImportRequest | null;
}

export interface CreateImportURLOperationRequest {
    createImportURLRequest: CreateImportURLRequest | null;
}

export interface CreateRoleOperationRequest {
    createRoleRequest: CreateRoleRequest | null;
}

export interface DeactivateUserOperationRequest {
    userId: string;
    deactivateUserRequest: DeactivateUserRequest | null;
}

export interface DeactivateUsersOperationRequest {
    deactivateUsersRequest: DeactivateUsersRequest | null;
}

export interface DeleteBlockListRequest {
    name: string;
}

export interface DeleteDeviceRequest {
    id: string;
    userId?: string;
}

export interface DeleteExternalStorageRequest {
    name: string;
}

export interface DeletePushProviderRequest {
    type: DeletePushProviderTypeEnum;
    name: string;
}

export interface DeleteRoleRequest {
    name: string;
}

export interface DeleteUsersOperationRequest {
    deleteUsersRequest: DeleteUsersRequest | null;
}

export interface ExportUserRequest {
    userId: string;
}

export interface ExportUsersOperationRequest {
    exportUsersRequest: ExportUsersRequest | null;
}

export interface FlagOperationRequest {
    flagRequest: FlagRequest | null;
}

export interface GetBlockListRequest {
    name: string;
}

export interface GetImportRequest {
    id: string;
}

export interface GetOGRequest {
    url: string;
}

export interface GetPermissionRequest {
    id: string;
}

export interface GetRateLimitsRequest {
    serverSide?: boolean;
    android?: boolean;
    ios?: boolean;
    web?: boolean;
    endpoints?: string;
}

export interface GetTaskRequest {
    id: string;
}

export interface ListDevicesRequest {
    userId?: string;
}

export interface MuteUserOperationRequest {
    muteUserRequest: MuteUserRequest | null;
}

export interface QueryUsersRequest {
    payload?: QueryUsersPayload;
}

export interface ReactivateUserOperationRequest {
    userId: string;
    reactivateUserRequest: ReactivateUserRequest | null;
}

export interface ReactivateUsersOperationRequest {
    reactivateUsersRequest: ReactivateUsersRequest | null;
}

export interface RestoreUsersOperationRequest {
    restoreUsersRequest: RestoreUsersRequest | null;
}

export interface UnbanRequest {
    targetUserId: string;
    channelCid?: string;
    createdBy?: string;
}

export interface UnmuteUserOperationRequest {
    unmuteUserRequest: UnmuteUserRequest | null;
}

export interface UpdateAppOperationRequest {
    updateAppRequest: UpdateAppRequest | null;
}

export interface UpdateBlockListOperationRequest {
    name: string;
    updateBlockListRequest: UpdateBlockListRequest | null;
}

export interface UpdateExternalStorageOperationRequest {
    name: string;
    updateExternalStorageRequest: UpdateExternalStorageRequest | null;
}

export interface UpdateUsersOperationRequest {
    updateUsersRequest: UpdateUsersRequest | null;
}

export interface UpdateUsersPartialOperationRequest {
    updateUsersPartialRequest: UpdateUsersPartialRequest | null;
}

export interface UpsertPushProviderOperationRequest {
    upsertPushProviderRequest: UpsertPushProviderRequest | null;
}

/**
 * 
 */
export class ProductcommonApi extends runtime.BaseAPI {

    /**
     * Restricts user activity either in specific channel or globally  Sends events: - user.banned  Required permissions: - BanChannelMember - BanUser 
     * Ban user
     */
    async banRaw(requestParameters: BanOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.banRequest === null || requestParameters.banRequest === undefined) {
            throw new runtime.RequiredError('banRequest','Required parameter requestParameters.banRequest was null or undefined when calling ban.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/moderation/ban`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.banRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Restricts user activity either in specific channel or globally  Sends events: - user.banned  Required permissions: - BanChannelMember - BanUser 
     * Ban user
     */
    async ban(requestParameters: BanOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.banRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  
     * Check External Storage
     */
    async checkExternalStorageRaw(requestParameters: CheckExternalStorageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckExternalStorageResponse>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling checkExternalStorage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/external_storage/{name}/check`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *  
     * Check External Storage
     */
    async checkExternalStorage(requestParameters: CheckExternalStorageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckExternalStorageResponse> {
        const response = await this.checkExternalStorageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sends a test message via push, this is a test endpoint to verify your push settings 
     * Check push
     */
    async checkPushRaw(requestParameters: CheckPushOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckPushResponse>> {
        if (requestParameters.checkPushRequest === null || requestParameters.checkPushRequest === undefined) {
            throw new runtime.RequiredError('checkPushRequest','Required parameter requestParameters.checkPushRequest was null or undefined when calling checkPush.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/check_push`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.checkPushRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sends a test message via push, this is a test endpoint to verify your push settings 
     * Check push
     */
    async checkPush(requestParameters: CheckPushOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckPushResponse> {
        const response = await this.checkPushRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Validates Amazon SNS configuration 
     * Check SNS
     */
    async checkSNSRaw(requestParameters: CheckSNSOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckSNSResponse>> {
        if (requestParameters.checkSNSRequest === null || requestParameters.checkSNSRequest === undefined) {
            throw new runtime.RequiredError('checkSNSRequest','Required parameter requestParameters.checkSNSRequest was null or undefined when calling checkSNS.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/check_sns`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.checkSNSRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Validates Amazon SNS configuration 
     * Check SNS
     */
    async checkSNS(requestParameters: CheckSNSOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckSNSResponse> {
        const response = await this.checkSNSRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Validates Amazon SQS credentials 
     * Check SQS
     */
    async checkSQSRaw(requestParameters: CheckSQSOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckSQSResponse>> {
        if (requestParameters.checkSQSRequest === null || requestParameters.checkSQSRequest === undefined) {
            throw new runtime.RequiredError('checkSQSRequest','Required parameter requestParameters.checkSQSRequest was null or undefined when calling checkSQS.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/check_sqs`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.checkSQSRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Validates Amazon SQS credentials 
     * Check SQS
     */
    async checkSQS(requestParameters: CheckSQSOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckSQSResponse> {
        const response = await this.checkSQSRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new application blocklist, once created the blocklist can be used by any channel type 
     * Create block list
     */
    async createBlockListRaw(requestParameters: CreateBlockListOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.createBlockListRequest === null || requestParameters.createBlockListRequest === undefined) {
            throw new runtime.RequiredError('createBlockListRequest','Required parameter requestParameters.createBlockListRequest was null or undefined when calling createBlockList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/blocklists`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createBlockListRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates a new application blocklist, once created the blocklist can be used by any channel type 
     * Create block list
     */
    async createBlockList(requestParameters: CreateBlockListOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.createBlockListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Adds a new device to a user, if the same device already exists the call will have no effect 
     * Create device
     */
    async createDeviceRaw(requestParameters: CreateDeviceOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.createDeviceRequest === null || requestParameters.createDeviceRequest === undefined) {
            throw new runtime.RequiredError('createDeviceRequest','Required parameter requestParameters.createDeviceRequest was null or undefined when calling createDevice.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/devices`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createDeviceRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Adds a new device to a user, if the same device already exists the call will have no effect 
     * Create device
     */
    async createDevice(requestParameters: CreateDeviceOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.createDeviceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates new external storage 
     * Create external storage
     */
    async createExternalStorageRaw(requestParameters: CreateExternalStorageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateExternalStorageResponse>> {
        if (requestParameters.createExternalStorageRequest === null || requestParameters.createExternalStorageRequest === undefined) {
            throw new runtime.RequiredError('createExternalStorageRequest','Required parameter requestParameters.createExternalStorageRequest was null or undefined when calling createExternalStorage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/external_storage`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createExternalStorageRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates new external storage 
     * Create external storage
     */
    async createExternalStorage(requestParameters: CreateExternalStorageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateExternalStorageResponse> {
        const response = await this.createExternalStorageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  
     * Create Guest
     */
    async createGuestRaw(requestParameters: CreateGuestOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateGuestResponse>> {
        if (requestParameters.createGuestRequest === null || requestParameters.createGuestRequest === undefined) {
            throw new runtime.RequiredError('createGuestRequest','Required parameter requestParameters.createGuestRequest was null or undefined when calling createGuest.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/guest`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createGuestRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *  
     * Create Guest
     */
    async createGuest(requestParameters: CreateGuestOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateGuestResponse> {
        const response = await this.createGuestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new import 
     * Create import
     */
    async createImportRaw(requestParameters: CreateImportOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateImportResponse>> {
        if (requestParameters.createImportRequest === null || requestParameters.createImportRequest === undefined) {
            throw new runtime.RequiredError('createImportRequest','Required parameter requestParameters.createImportRequest was null or undefined when calling createImport.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/imports`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createImportRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates a new import 
     * Create import
     */
    async createImport(requestParameters: CreateImportOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateImportResponse> {
        const response = await this.createImportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new import URL 
     * Create import URL
     */
    async createImportURLRaw(requestParameters: CreateImportURLOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateImportURLResponse>> {
        if (requestParameters.createImportURLRequest === null || requestParameters.createImportURLRequest === undefined) {
            throw new runtime.RequiredError('createImportURLRequest','Required parameter requestParameters.createImportURLRequest was null or undefined when calling createImportURL.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/import_urls`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createImportURLRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates a new import URL 
     * Create import URL
     */
    async createImportURL(requestParameters: CreateImportURLOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateImportURLResponse> {
        const response = await this.createImportURLRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates custom role 
     * Create role
     */
    async createRoleRaw(requestParameters: CreateRoleOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateRoleResponse>> {
        if (requestParameters.createRoleRequest === null || requestParameters.createRoleRequest === undefined) {
            throw new runtime.RequiredError('createRoleRequest','Required parameter requestParameters.createRoleRequest was null or undefined when calling createRole.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/roles`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createRoleRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates custom role 
     * Create role
     */
    async createRole(requestParameters: CreateRoleOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateRoleResponse> {
        const response = await this.createRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deactivates user with possibility to activate it back  Sends events: - user.deactivated 
     * Deactivate user
     */
    async deactivateUserRaw(requestParameters: DeactivateUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeactivateUserResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling deactivateUser.');
        }

        if (requestParameters.deactivateUserRequest === null || requestParameters.deactivateUserRequest === undefined) {
            throw new runtime.RequiredError('deactivateUserRequest','Required parameter requestParameters.deactivateUserRequest was null or undefined when calling deactivateUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/users/{user_id}/deactivate`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.deactivateUserRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deactivates user with possibility to activate it back  Sends events: - user.deactivated 
     * Deactivate user
     */
    async deactivateUser(requestParameters: DeactivateUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeactivateUserResponse> {
        const response = await this.deactivateUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deactivate users in batches  Sends events: - user.deactivated 
     * Deactivate users
     */
    async deactivateUsersRaw(requestParameters: DeactivateUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeactivateUsersResponse>> {
        if (requestParameters.deactivateUsersRequest === null || requestParameters.deactivateUsersRequest === undefined) {
            throw new runtime.RequiredError('deactivateUsersRequest','Required parameter requestParameters.deactivateUsersRequest was null or undefined when calling deactivateUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/users/deactivate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.deactivateUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deactivate users in batches  Sends events: - user.deactivated 
     * Deactivate users
     */
    async deactivateUsers(requestParameters: DeactivateUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeactivateUsersResponse> {
        const response = await this.deactivateUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes previously created application blocklist 
     * Delete block list
     */
    async deleteBlockListRaw(requestParameters: DeleteBlockListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteBlockList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/blocklists/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes previously created application blocklist 
     * Delete block list
     */
    async deleteBlockList(requestParameters: DeleteBlockListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.deleteBlockListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes one device 
     * Delete device
     */
    async deleteDeviceRaw(requestParameters: DeleteDeviceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteDevice.');
        }

        const queryParameters: any = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/devices`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes one device 
     * Delete device
     */
    async deleteDevice(requestParameters: DeleteDeviceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.deleteDeviceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes external storage 
     * Delete external storage
     */
    async deleteExternalStorageRaw(requestParameters: DeleteExternalStorageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteExternalStorageResponse>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteExternalStorage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/external_storage/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes external storage 
     * Delete external storage
     */
    async deleteExternalStorage(requestParameters: DeleteExternalStorageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteExternalStorageResponse> {
        const response = await this.deleteExternalStorageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a push provider from v2 with multi bundle/package support. v1 isn\'t supported in this endpoint 
     * Delete a push provider
     */
    async deletePushProviderRaw(requestParameters: DeletePushProviderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling deletePushProvider.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deletePushProvider.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/push_providers/{type}/{name}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Delete a push provider from v2 with multi bundle/package support. v1 isn\'t supported in this endpoint 
     * Delete a push provider
     */
    async deletePushProvider(requestParameters: DeletePushProviderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.deletePushProviderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes custom role 
     * Delete role
     */
    async deleteRoleRaw(requestParameters: DeleteRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteRole.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/roles/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes custom role 
     * Delete role
     */
    async deleteRole(requestParameters: DeleteRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.deleteRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes users and optionally all their belongings asynchronously.  Sends events: - channel.deleted - user.deleted 
     * Delete Users
     */
    async deleteUsersRaw(requestParameters: DeleteUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteUsersResponse>> {
        if (requestParameters.deleteUsersRequest === null || requestParameters.deleteUsersRequest === undefined) {
            throw new runtime.RequiredError('deleteUsersRequest','Required parameter requestParameters.deleteUsersRequest was null or undefined when calling deleteUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/users/delete`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.deleteUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes users and optionally all their belongings asynchronously.  Sends events: - channel.deleted - user.deleted 
     * Delete Users
     */
    async deleteUsers(requestParameters: DeleteUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteUsersResponse> {
        const response = await this.deleteUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Exports the user\'s profile, reactions and messages. Raises an error if a user has more than 10k messages or reactions 
     * Export user
     */
    async exportUserRaw(requestParameters: ExportUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportUserResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling exportUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/users/{user_id}/export`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Exports the user\'s profile, reactions and messages. Raises an error if a user has more than 10k messages or reactions 
     * Export user
     */
    async exportUser(requestParameters: ExportUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportUserResponse> {
        const response = await this.exportUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Exports user profile, reactions and messages for list of given users 
     * Export users
     */
    async exportUsersRaw(requestParameters: ExportUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportUsersResponse>> {
        if (requestParameters.exportUsersRequest === null || requestParameters.exportUsersRequest === undefined) {
            throw new runtime.RequiredError('exportUsersRequest','Required parameter requestParameters.exportUsersRequest was null or undefined when calling exportUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/export/users`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.exportUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Exports user profile, reactions and messages for list of given users 
     * Export users
     */
    async exportUsers(requestParameters: ExportUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportUsersResponse> {
        const response = await this.exportUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser 
     * Flag
     */
    async flagRaw(requestParameters: FlagOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FlagResponse>> {
        if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {
            throw new runtime.RequiredError('flagRequest','Required parameter requestParameters.flagRequest was null or undefined when calling flag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/moderation/flag`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.flagRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser 
     * Flag
     */
    async flag(requestParameters: FlagOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FlagResponse> {
        const response = await this.flagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This Method returns the application settings 
     * Get App Settings
     */
    async getAppRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetApplicationResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/app`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * This Method returns the application settings 
     * Get App Settings
     */
    async getApp(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetApplicationResponse> {
        const response = await this.getAppRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns block list by given name 
     * Get block list
     */
    async getBlockListRaw(requestParameters: GetBlockListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetBlockListResponse>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getBlockList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/blocklists/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns block list by given name 
     * Get block list
     */
    async getBlockList(requestParameters: GetBlockListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetBlockListResponse> {
        const response = await this.getBlockListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets an import 
     * Get import
     */
    async getImportRaw(requestParameters: GetImportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetImportResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getImport.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/imports/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets an import 
     * Get import
     */
    async getImport(requestParameters: GetImportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetImportResponse> {
        const response = await this.getImportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get an OpenGraph attachment for a link 
     * Get OG
     */
    async getOGRaw(requestParameters: GetOGRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetOGResponse>> {
        if (requestParameters.url === null || requestParameters.url === undefined) {
            throw new runtime.RequiredError('url','Required parameter requestParameters.url was null or undefined when calling getOG.');
        }

        const queryParameters: any = {};

        if (requestParameters.url !== undefined) {
            queryParameters['url'] = requestParameters.url;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/og`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get an OpenGraph attachment for a link 
     * Get OG
     */
    async getOG(requestParameters: GetOGRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetOGResponse> {
        const response = await this.getOGRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets custom permission 
     * Get permission
     */
    async getPermissionRaw(requestParameters: GetPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCustomPermissionResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getPermission.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/permissions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets custom permission 
     * Get permission
     */
    async getPermission(requestParameters: GetPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCustomPermissionResponse> {
        const response = await this.getPermissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get rate limits usage and quotas 
     * Get rate limits
     */
    async getRateLimitsRaw(requestParameters: GetRateLimitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRateLimitsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.serverSide !== undefined) {
            queryParameters['server_side'] = requestParameters.serverSide;
        }

        if (requestParameters.android !== undefined) {
            queryParameters['android'] = requestParameters.android;
        }

        if (requestParameters.ios !== undefined) {
            queryParameters['ios'] = requestParameters.ios;
        }

        if (requestParameters.web !== undefined) {
            queryParameters['web'] = requestParameters.web;
        }

        if (requestParameters.endpoints !== undefined) {
            queryParameters['endpoints'] = requestParameters.endpoints;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/rate_limits`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get rate limits usage and quotas 
     * Get rate limits
     */
    async getRateLimits(requestParameters: GetRateLimitsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRateLimitsResponse> {
        const response = await this.getRateLimitsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets status of a task 
     * Get status of a task
     */
    async getTaskRaw(requestParameters: GetTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetTaskResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getTask.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/tasks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets status of a task 
     * Get status of a task
     */
    async getTask(requestParameters: GetTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetTaskResponse> {
        const response = await this.getTaskRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all available block lists 
     * List block lists
     */
    async listBlockListsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListBlockListResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/blocklists`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns all available block lists 
     * List block lists
     */
    async listBlockLists(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListBlockListResponse> {
        const response = await this.listBlockListsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns all available devices 
     * List devices
     */
    async listDevicesRaw(requestParameters: ListDevicesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListDevicesResponse>> {
        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/devices`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns all available devices 
     * List devices
     */
    async listDevices(requestParameters: ListDevicesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListDevicesResponse> {
        const response = await this.listDevicesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists external storage 
     * List external storage
     */
    async listExternalStorageRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListExternalStorageResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/external_storage`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Lists external storage 
     * List external storage
     */
    async listExternalStorage(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListExternalStorageResponse> {
        const response = await this.listExternalStorageRaw(initOverrides);
        return await response.value();
    }

    /**
     * Gets an import 
     * Get import
     */
    async listImportsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListImportsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/imports`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets an import 
     * Get import
     */
    async listImports(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListImportsResponse> {
        const response = await this.listImportsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Lists all available permissions 
     * List permissions
     */
    async listPermissionsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListPermissionsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/permissions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Lists all available permissions 
     * List permissions
     */
    async listPermissions(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListPermissionsResponse> {
        const response = await this.listPermissionsRaw(initOverrides);
        return await response.value();
    }

    /**
     * List details of all push providers. 
     * List push providers
     */
    async listPushProvidersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListPushProvidersResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/push_providers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * List details of all push providers. 
     * List push providers
     */
    async listPushProviders(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListPushProvidersResponse> {
        const response = await this.listPushProvidersRaw(initOverrides);
        return await response.value();
    }

    /**
     * Lists all available roles 
     * List roles
     */
    async listRolesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListRolesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/roles`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Lists all available roles 
     * List roles
     */
    async listRoles(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListRolesResponse> {
        const response = await this.listRolesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Mutes one or several users  Sends events: - user.muted  Required permissions: - MuteUser 
     * Mute user
     */
    async muteUserRaw(requestParameters: MuteUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MuteUserResponse>> {
        if (requestParameters.muteUserRequest === null || requestParameters.muteUserRequest === undefined) {
            throw new runtime.RequiredError('muteUserRequest','Required parameter requestParameters.muteUserRequest was null or undefined when calling muteUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/moderation/mute`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.muteUserRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Mutes one or several users  Sends events: - user.muted  Required permissions: - MuteUser 
     * Mute user
     */
    async muteUser(requestParameters: MuteUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MuteUserResponse> {
        const response = await this.muteUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find and filter users  Required permissions: - SearchUser 
     * Query users
     */
    async queryUsersRaw(requestParameters: QueryUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryUsersResponse>> {
        const queryParameters: any = {};

        if (requestParameters.payload !== undefined) {
            queryParameters['payload'] = requestParameters.payload;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find and filter users  Required permissions: - SearchUser 
     * Query users
     */
    async queryUsers(requestParameters: QueryUsersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryUsersResponse> {
        const response = await this.queryUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Activates user who\'s been deactivated previously  Sends events: - user.reactivated 
     * Reactivate user
     */
    async reactivateUserRaw(requestParameters: ReactivateUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReactivateUserResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling reactivateUser.');
        }

        if (requestParameters.reactivateUserRequest === null || requestParameters.reactivateUserRequest === undefined) {
            throw new runtime.RequiredError('reactivateUserRequest','Required parameter requestParameters.reactivateUserRequest was null or undefined when calling reactivateUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/users/{user_id}/reactivate`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.reactivateUserRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Activates user who\'s been deactivated previously  Sends events: - user.reactivated 
     * Reactivate user
     */
    async reactivateUser(requestParameters: ReactivateUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReactivateUserResponse> {
        const response = await this.reactivateUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reactivate users in batches  Sends events: - user.reactivated 
     * Reactivate users
     */
    async reactivateUsersRaw(requestParameters: ReactivateUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReactivateUsersResponse>> {
        if (requestParameters.reactivateUsersRequest === null || requestParameters.reactivateUsersRequest === undefined) {
            throw new runtime.RequiredError('reactivateUsersRequest','Required parameter requestParameters.reactivateUsersRequest was null or undefined when calling reactivateUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/users/reactivate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.reactivateUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Reactivate users in batches  Sends events: - user.reactivated 
     * Reactivate users
     */
    async reactivateUsers(requestParameters: ReactivateUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReactivateUsersResponse> {
        const response = await this.reactivateUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Restore soft deleted users 
     * Restore users
     */
    async restoreUsersRaw(requestParameters: RestoreUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.restoreUsersRequest === null || requestParameters.restoreUsersRequest === undefined) {
            throw new runtime.RequiredError('restoreUsersRequest','Required parameter requestParameters.restoreUsersRequest was null or undefined when calling restoreUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/users/restore`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restoreUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Restore soft deleted users 
     * Restore users
     */
    async restoreUsers(requestParameters: RestoreUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.restoreUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Removes previously applied ban  Sends events: - user.unbanned  Required permissions: - BanChannelMember - BanUser 
     * Unban user
     */
    async unbanRaw(requestParameters: UnbanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.targetUserId === null || requestParameters.targetUserId === undefined) {
            throw new runtime.RequiredError('targetUserId','Required parameter requestParameters.targetUserId was null or undefined when calling unban.');
        }

        const queryParameters: any = {};

        if (requestParameters.targetUserId !== undefined) {
            queryParameters['target_user_id'] = requestParameters.targetUserId;
        }

        if (requestParameters.channelCid !== undefined) {
            queryParameters['channel_cid'] = requestParameters.channelCid;
        }

        if (requestParameters.createdBy !== undefined) {
            queryParameters['created_by'] = requestParameters.createdBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/moderation/ban`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Removes previously applied ban  Sends events: - user.unbanned  Required permissions: - BanChannelMember - BanUser 
     * Unban user
     */
    async unban(requestParameters: UnbanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.unbanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unmutes previously muted user  Sends events: - user.unmuted  Required permissions: - MuteUser 
     * Unmute user
     */
    async unmuteUserRaw(requestParameters: UnmuteUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UnmuteResponse>> {
        if (requestParameters.unmuteUserRequest === null || requestParameters.unmuteUserRequest === undefined) {
            throw new runtime.RequiredError('unmuteUserRequest','Required parameter requestParameters.unmuteUserRequest was null or undefined when calling unmuteUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/moderation/unmute`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.unmuteUserRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Unmutes previously muted user  Sends events: - user.unmuted  Required permissions: - MuteUser 
     * Unmute user
     */
    async unmuteUser(requestParameters: UnmuteUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UnmuteResponse> {
        const response = await this.unmuteUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This Method updates one or more application settings 
     * Update App Settings
     */
    async updateAppRaw(requestParameters: UpdateAppOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.updateAppRequest === null || requestParameters.updateAppRequest === undefined) {
            throw new runtime.RequiredError('updateAppRequest','Required parameter requestParameters.updateAppRequest was null or undefined when calling updateApp.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/app`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateAppRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * This Method updates one or more application settings 
     * Update App Settings
     */
    async updateApp(requestParameters: UpdateAppOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.updateAppRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates contents of the block list 
     * Update block list
     */
    async updateBlockListRaw(requestParameters: UpdateBlockListOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Response>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling updateBlockList.');
        }

        if (requestParameters.updateBlockListRequest === null || requestParameters.updateBlockListRequest === undefined) {
            throw new runtime.RequiredError('updateBlockListRequest','Required parameter requestParameters.updateBlockListRequest was null or undefined when calling updateBlockList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/blocklists/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateBlockListRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates contents of the block list 
     * Update block list
     */
    async updateBlockList(requestParameters: UpdateBlockListOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Response> {
        const response = await this.updateBlockListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  
     * Update External Storage
     */
    async updateExternalStorageRaw(requestParameters: UpdateExternalStorageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateExternalStorageResponse>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling updateExternalStorage.');
        }

        if (requestParameters.updateExternalStorageRequest === null || requestParameters.updateExternalStorageRequest === undefined) {
            throw new runtime.RequiredError('updateExternalStorageRequest','Required parameter requestParameters.updateExternalStorageRequest was null or undefined when calling updateExternalStorage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/external_storage/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateExternalStorageRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *  
     * Update External Storage
     */
    async updateExternalStorage(requestParameters: UpdateExternalStorageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateExternalStorageResponse> {
        const response = await this.updateExternalStorageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update or create users in bulk  Sends events: - user.updated 
     * Upsert users
     */
    async updateUsersRaw(requestParameters: UpdateUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateUsersResponse>> {
        if (requestParameters.updateUsersRequest === null || requestParameters.updateUsersRequest === undefined) {
            throw new runtime.RequiredError('updateUsersRequest','Required parameter requestParameters.updateUsersRequest was null or undefined when calling updateUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/users`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateUsersRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update or create users in bulk  Sends events: - user.updated 
     * Upsert users
     */
    async updateUsers(requestParameters: UpdateUsersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateUsersResponse> {
        const response = await this.updateUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates certain fields of the user  Sends events: - user.presence.changed - user.updated 
     * Partially update user
     */
    async updateUsersPartialRaw(requestParameters: UpdateUsersPartialOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateUsersResponse>> {
        if (requestParameters.updateUsersPartialRequest === null || requestParameters.updateUsersPartialRequest === undefined) {
            throw new runtime.RequiredError('updateUsersPartialRequest','Required parameter requestParameters.updateUsersPartialRequest was null or undefined when calling updateUsersPartial.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/users`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.updateUsersPartialRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates certain fields of the user  Sends events: - user.presence.changed - user.updated 
     * Partially update user
     */
    async updateUsersPartial(requestParameters: UpdateUsersPartialOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateUsersResponse> {
        const response = await this.updateUsersPartialRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upsert a push provider for v2 with multi bundle/package support 
     * Upsert a push provider
     */
    async upsertPushProviderRaw(requestParameters: UpsertPushProviderOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpsertPushProviderResponse>> {
        if (requestParameters.upsertPushProviderRequest === null || requestParameters.upsertPushProviderRequest === undefined) {
            throw new runtime.RequiredError('upsertPushProviderRequest','Required parameter requestParameters.upsertPushProviderRequest was null or undefined when calling upsertPushProvider.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        const response = await this.request({
            path: `/api/v2/push_providers`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.upsertPushProviderRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Upsert a push provider for v2 with multi bundle/package support 
     * Upsert a push provider
     */
    async upsertPushProvider(requestParameters: UpsertPushProviderOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpsertPushProviderResponse> {
        const response = await this.upsertPushProviderRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const DeletePushProviderTypeEnum = {
    APN: 'apn',
    FIREBASE: 'firebase',
    HUAWEI: 'huawei',
    XIAOMI: 'xiaomi'
} as const;
export type DeletePushProviderTypeEnum = typeof DeletePushProviderTypeEnum[keyof typeof DeletePushProviderTypeEnum];
